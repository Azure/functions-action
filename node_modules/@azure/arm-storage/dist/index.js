'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreLro = require('@azure/core-lro');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespace(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const pageMap = new WeakMap();
/**
 * Given the last `.value` produced by the `byPage` iterator,
 * returns a continuation token that can be used to begin paging from
 * that point later.
 * @param page An object from accessing `value` on the IteratorResult from a `byPage` iterator.
 * @returns The continuation token that can be passed into byPage() during future calls.
 */
function getContinuationToken(page) {
    var _a;
    if (typeof page !== "object" || page === null) {
        return undefined;
    }
    return (_a = pageMap.get(page)) === null || _a === void 0 ? void 0 : _a.continuationToken;
}
function setContinuationToken(page, continuationToken) {
    var _a;
    if (typeof page !== "object" || page === null || !continuationToken) {
        return;
    }
    const pageInfo = (_a = pageMap.get(page)) !== null && _a !== void 0 ? _a : {};
    pageInfo.continuationToken = continuationToken;
    pageMap.set(page, pageInfo);
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link SkuName} that the service accepts. */
exports.KnownSkuName = void 0;
(function (KnownSkuName) {
    /** StandardLRS */
    KnownSkuName["StandardLRS"] = "Standard_LRS";
    /** StandardGRS */
    KnownSkuName["StandardGRS"] = "Standard_GRS";
    /** StandardRagrs */
    KnownSkuName["StandardRagrs"] = "Standard_RAGRS";
    /** StandardZRS */
    KnownSkuName["StandardZRS"] = "Standard_ZRS";
    /** PremiumLRS */
    KnownSkuName["PremiumLRS"] = "Premium_LRS";
    /** PremiumZRS */
    KnownSkuName["PremiumZRS"] = "Premium_ZRS";
    /** StandardGzrs */
    KnownSkuName["StandardGzrs"] = "Standard_GZRS";
    /** StandardRagzrs */
    KnownSkuName["StandardRagzrs"] = "Standard_RAGZRS";
})(exports.KnownSkuName || (exports.KnownSkuName = {}));
/** Known values of {@link Kind} that the service accepts. */
exports.KnownKind = void 0;
(function (KnownKind) {
    /** Storage */
    KnownKind["Storage"] = "Storage";
    /** StorageV2 */
    KnownKind["StorageV2"] = "StorageV2";
    /** BlobStorage */
    KnownKind["BlobStorage"] = "BlobStorage";
    /** FileStorage */
    KnownKind["FileStorage"] = "FileStorage";
    /** BlockBlobStorage */
    KnownKind["BlockBlobStorage"] = "BlockBlobStorage";
})(exports.KnownKind || (exports.KnownKind = {}));
/** Known values of {@link ReasonCode} that the service accepts. */
exports.KnownReasonCode = void 0;
(function (KnownReasonCode) {
    /** QuotaId */
    KnownReasonCode["QuotaId"] = "QuotaId";
    /** NotAvailableForSubscription */
    KnownReasonCode["NotAvailableForSubscription"] = "NotAvailableForSubscription";
})(exports.KnownReasonCode || (exports.KnownReasonCode = {}));
/** Known values of {@link ExtendedLocationTypes} that the service accepts. */
exports.KnownExtendedLocationTypes = void 0;
(function (KnownExtendedLocationTypes) {
    /** EdgeZone */
    KnownExtendedLocationTypes["EdgeZone"] = "EdgeZone";
})(exports.KnownExtendedLocationTypes || (exports.KnownExtendedLocationTypes = {}));
/** Known values of {@link IdentityType} that the service accepts. */
exports.KnownIdentityType = void 0;
(function (KnownIdentityType) {
    /** None */
    KnownIdentityType["None"] = "None";
    /** SystemAssigned */
    KnownIdentityType["SystemAssigned"] = "SystemAssigned";
    /** UserAssigned */
    KnownIdentityType["UserAssigned"] = "UserAssigned";
    /** SystemAssignedUserAssigned */
    KnownIdentityType["SystemAssignedUserAssigned"] = "SystemAssigned,UserAssigned";
})(exports.KnownIdentityType || (exports.KnownIdentityType = {}));
/** Known values of {@link AllowedCopyScope} that the service accepts. */
exports.KnownAllowedCopyScope = void 0;
(function (KnownAllowedCopyScope) {
    /** PrivateLink */
    KnownAllowedCopyScope["PrivateLink"] = "PrivateLink";
    /** AAD */
    KnownAllowedCopyScope["AAD"] = "AAD";
})(exports.KnownAllowedCopyScope || (exports.KnownAllowedCopyScope = {}));
/** Known values of {@link PublicNetworkAccess} that the service accepts. */
exports.KnownPublicNetworkAccess = void 0;
(function (KnownPublicNetworkAccess) {
    /** Enabled */
    KnownPublicNetworkAccess["Enabled"] = "Enabled";
    /** Disabled */
    KnownPublicNetworkAccess["Disabled"] = "Disabled";
})(exports.KnownPublicNetworkAccess || (exports.KnownPublicNetworkAccess = {}));
/** Known values of {@link ExpirationAction} that the service accepts. */
exports.KnownExpirationAction = void 0;
(function (KnownExpirationAction) {
    /** Log */
    KnownExpirationAction["Log"] = "Log";
})(exports.KnownExpirationAction || (exports.KnownExpirationAction = {}));
/** Known values of {@link KeyType} that the service accepts. */
exports.KnownKeyType = void 0;
(function (KnownKeyType) {
    /** Service */
    KnownKeyType["Service"] = "Service";
    /** Account */
    KnownKeyType["Account"] = "Account";
})(exports.KnownKeyType || (exports.KnownKeyType = {}));
/** Known values of {@link KeySource} that the service accepts. */
exports.KnownKeySource = void 0;
(function (KnownKeySource) {
    /** MicrosoftStorage */
    KnownKeySource["MicrosoftStorage"] = "Microsoft.Storage";
    /** MicrosoftKeyvault */
    KnownKeySource["MicrosoftKeyvault"] = "Microsoft.Keyvault";
})(exports.KnownKeySource || (exports.KnownKeySource = {}));
/** Known values of {@link Bypass} that the service accepts. */
exports.KnownBypass = void 0;
(function (KnownBypass) {
    /** None */
    KnownBypass["None"] = "None";
    /** Logging */
    KnownBypass["Logging"] = "Logging";
    /** Metrics */
    KnownBypass["Metrics"] = "Metrics";
    /** AzureServices */
    KnownBypass["AzureServices"] = "AzureServices";
})(exports.KnownBypass || (exports.KnownBypass = {}));
/** Known values of {@link State} that the service accepts. */
exports.KnownState = void 0;
(function (KnownState) {
    /** Provisioning */
    KnownState["Provisioning"] = "Provisioning";
    /** Deprovisioning */
    KnownState["Deprovisioning"] = "Deprovisioning";
    /** Succeeded */
    KnownState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownState["Failed"] = "Failed";
    /** NetworkSourceDeleted */
    KnownState["NetworkSourceDeleted"] = "NetworkSourceDeleted";
})(exports.KnownState || (exports.KnownState = {}));
/** Known values of {@link DirectoryServiceOptions} that the service accepts. */
exports.KnownDirectoryServiceOptions = void 0;
(function (KnownDirectoryServiceOptions) {
    /** None */
    KnownDirectoryServiceOptions["None"] = "None";
    /** Aadds */
    KnownDirectoryServiceOptions["Aadds"] = "AADDS";
    /** AD */
    KnownDirectoryServiceOptions["AD"] = "AD";
    /** Aadkerb */
    KnownDirectoryServiceOptions["Aadkerb"] = "AADKERB";
})(exports.KnownDirectoryServiceOptions || (exports.KnownDirectoryServiceOptions = {}));
/** Known values of {@link AccountType} that the service accepts. */
exports.KnownAccountType = void 0;
(function (KnownAccountType) {
    /** User */
    KnownAccountType["User"] = "User";
    /** Computer */
    KnownAccountType["Computer"] = "Computer";
})(exports.KnownAccountType || (exports.KnownAccountType = {}));
/** Known values of {@link DefaultSharePermission} that the service accepts. */
exports.KnownDefaultSharePermission = void 0;
(function (KnownDefaultSharePermission) {
    /** None */
    KnownDefaultSharePermission["None"] = "None";
    /** StorageFileDataSmbShareReader */
    KnownDefaultSharePermission["StorageFileDataSmbShareReader"] = "StorageFileDataSmbShareReader";
    /** StorageFileDataSmbShareContributor */
    KnownDefaultSharePermission["StorageFileDataSmbShareContributor"] = "StorageFileDataSmbShareContributor";
    /** StorageFileDataSmbShareElevatedContributor */
    KnownDefaultSharePermission["StorageFileDataSmbShareElevatedContributor"] = "StorageFileDataSmbShareElevatedContributor";
})(exports.KnownDefaultSharePermission || (exports.KnownDefaultSharePermission = {}));
/** Known values of {@link LargeFileSharesState} that the service accepts. */
exports.KnownLargeFileSharesState = void 0;
(function (KnownLargeFileSharesState) {
    /** Disabled */
    KnownLargeFileSharesState["Disabled"] = "Disabled";
    /** Enabled */
    KnownLargeFileSharesState["Enabled"] = "Enabled";
})(exports.KnownLargeFileSharesState || (exports.KnownLargeFileSharesState = {}));
/** Known values of {@link RoutingChoice} that the service accepts. */
exports.KnownRoutingChoice = void 0;
(function (KnownRoutingChoice) {
    /** MicrosoftRouting */
    KnownRoutingChoice["MicrosoftRouting"] = "MicrosoftRouting";
    /** InternetRouting */
    KnownRoutingChoice["InternetRouting"] = "InternetRouting";
})(exports.KnownRoutingChoice || (exports.KnownRoutingChoice = {}));
/** Known values of {@link MinimumTlsVersion} that the service accepts. */
exports.KnownMinimumTlsVersion = void 0;
(function (KnownMinimumTlsVersion) {
    /** TLS10 */
    KnownMinimumTlsVersion["TLS10"] = "TLS1_0";
    /** TLS11 */
    KnownMinimumTlsVersion["TLS11"] = "TLS1_1";
    /** TLS12 */
    KnownMinimumTlsVersion["TLS12"] = "TLS1_2";
})(exports.KnownMinimumTlsVersion || (exports.KnownMinimumTlsVersion = {}));
/** Known values of {@link AccountImmutabilityPolicyState} that the service accepts. */
exports.KnownAccountImmutabilityPolicyState = void 0;
(function (KnownAccountImmutabilityPolicyState) {
    /** Unlocked */
    KnownAccountImmutabilityPolicyState["Unlocked"] = "Unlocked";
    /** Locked */
    KnownAccountImmutabilityPolicyState["Locked"] = "Locked";
    /** Disabled */
    KnownAccountImmutabilityPolicyState["Disabled"] = "Disabled";
})(exports.KnownAccountImmutabilityPolicyState || (exports.KnownAccountImmutabilityPolicyState = {}));
/** Known values of {@link DnsEndpointType} that the service accepts. */
exports.KnownDnsEndpointType = void 0;
(function (KnownDnsEndpointType) {
    /** Standard */
    KnownDnsEndpointType["Standard"] = "Standard";
    /** AzureDnsZone */
    KnownDnsEndpointType["AzureDnsZone"] = "AzureDnsZone";
})(exports.KnownDnsEndpointType || (exports.KnownDnsEndpointType = {}));
/** Known values of {@link GeoReplicationStatus} that the service accepts. */
exports.KnownGeoReplicationStatus = void 0;
(function (KnownGeoReplicationStatus) {
    /** Live */
    KnownGeoReplicationStatus["Live"] = "Live";
    /** Bootstrap */
    KnownGeoReplicationStatus["Bootstrap"] = "Bootstrap";
    /** Unavailable */
    KnownGeoReplicationStatus["Unavailable"] = "Unavailable";
})(exports.KnownGeoReplicationStatus || (exports.KnownGeoReplicationStatus = {}));
/** Known values of {@link PostFailoverRedundancy} that the service accepts. */
exports.KnownPostFailoverRedundancy = void 0;
(function (KnownPostFailoverRedundancy) {
    /** StandardLRS */
    KnownPostFailoverRedundancy["StandardLRS"] = "Standard_LRS";
    /** StandardZRS */
    KnownPostFailoverRedundancy["StandardZRS"] = "Standard_ZRS";
})(exports.KnownPostFailoverRedundancy || (exports.KnownPostFailoverRedundancy = {}));
/** Known values of {@link PostPlannedFailoverRedundancy} that the service accepts. */
exports.KnownPostPlannedFailoverRedundancy = void 0;
(function (KnownPostPlannedFailoverRedundancy) {
    /** StandardGRS */
    KnownPostPlannedFailoverRedundancy["StandardGRS"] = "Standard_GRS";
    /** StandardGzrs */
    KnownPostPlannedFailoverRedundancy["StandardGzrs"] = "Standard_GZRS";
    /** StandardRagrs */
    KnownPostPlannedFailoverRedundancy["StandardRagrs"] = "Standard_RAGRS";
    /** StandardRagzrs */
    KnownPostPlannedFailoverRedundancy["StandardRagzrs"] = "Standard_RAGZRS";
})(exports.KnownPostPlannedFailoverRedundancy || (exports.KnownPostPlannedFailoverRedundancy = {}));
/** Known values of {@link PrivateEndpointServiceConnectionStatus} that the service accepts. */
exports.KnownPrivateEndpointServiceConnectionStatus = void 0;
(function (KnownPrivateEndpointServiceConnectionStatus) {
    /** Pending */
    KnownPrivateEndpointServiceConnectionStatus["Pending"] = "Pending";
    /** Approved */
    KnownPrivateEndpointServiceConnectionStatus["Approved"] = "Approved";
    /** Rejected */
    KnownPrivateEndpointServiceConnectionStatus["Rejected"] = "Rejected";
})(exports.KnownPrivateEndpointServiceConnectionStatus || (exports.KnownPrivateEndpointServiceConnectionStatus = {}));
/** Known values of {@link PrivateEndpointConnectionProvisioningState} that the service accepts. */
exports.KnownPrivateEndpointConnectionProvisioningState = void 0;
(function (KnownPrivateEndpointConnectionProvisioningState) {
    /** Succeeded */
    KnownPrivateEndpointConnectionProvisioningState["Succeeded"] = "Succeeded";
    /** Creating */
    KnownPrivateEndpointConnectionProvisioningState["Creating"] = "Creating";
    /** Deleting */
    KnownPrivateEndpointConnectionProvisioningState["Deleting"] = "Deleting";
    /** Failed */
    KnownPrivateEndpointConnectionProvisioningState["Failed"] = "Failed";
})(exports.KnownPrivateEndpointConnectionProvisioningState || (exports.KnownPrivateEndpointConnectionProvisioningState = {}));
/** Known values of {@link BlobRestoreProgressStatus} that the service accepts. */
exports.KnownBlobRestoreProgressStatus = void 0;
(function (KnownBlobRestoreProgressStatus) {
    /** InProgress */
    KnownBlobRestoreProgressStatus["InProgress"] = "InProgress";
    /** Complete */
    KnownBlobRestoreProgressStatus["Complete"] = "Complete";
    /** Failed */
    KnownBlobRestoreProgressStatus["Failed"] = "Failed";
})(exports.KnownBlobRestoreProgressStatus || (exports.KnownBlobRestoreProgressStatus = {}));
/** Known values of {@link SkuConversionStatus} that the service accepts. */
exports.KnownSkuConversionStatus = void 0;
(function (KnownSkuConversionStatus) {
    /** InProgress */
    KnownSkuConversionStatus["InProgress"] = "InProgress";
    /** Succeeded */
    KnownSkuConversionStatus["Succeeded"] = "Succeeded";
    /** Failed */
    KnownSkuConversionStatus["Failed"] = "Failed";
})(exports.KnownSkuConversionStatus || (exports.KnownSkuConversionStatus = {}));
/** Known values of {@link Services} that the service accepts. */
exports.KnownServices = void 0;
(function (KnownServices) {
    /** B */
    KnownServices["B"] = "b";
    /** Q */
    KnownServices["Q"] = "q";
    /** T */
    KnownServices["T"] = "t";
    /** F */
    KnownServices["F"] = "f";
})(exports.KnownServices || (exports.KnownServices = {}));
/** Known values of {@link SignedResourceTypes} that the service accepts. */
exports.KnownSignedResourceTypes = void 0;
(function (KnownSignedResourceTypes) {
    /** S */
    KnownSignedResourceTypes["S"] = "s";
    /** C */
    KnownSignedResourceTypes["C"] = "c";
    /** O */
    KnownSignedResourceTypes["O"] = "o";
})(exports.KnownSignedResourceTypes || (exports.KnownSignedResourceTypes = {}));
/** Known values of {@link Permissions} that the service accepts. */
exports.KnownPermissions = void 0;
(function (KnownPermissions) {
    /** R */
    KnownPermissions["R"] = "r";
    /** D */
    KnownPermissions["D"] = "d";
    /** W */
    KnownPermissions["W"] = "w";
    /** L */
    KnownPermissions["L"] = "l";
    /** A */
    KnownPermissions["A"] = "a";
    /** C */
    KnownPermissions["C"] = "c";
    /** U */
    KnownPermissions["U"] = "u";
    /** P */
    KnownPermissions["P"] = "p";
})(exports.KnownPermissions || (exports.KnownPermissions = {}));
/** Known values of {@link SignedResource} that the service accepts. */
exports.KnownSignedResource = void 0;
(function (KnownSignedResource) {
    /** B */
    KnownSignedResource["B"] = "b";
    /** C */
    KnownSignedResource["C"] = "c";
    /** F */
    KnownSignedResource["F"] = "f";
    /** S */
    KnownSignedResource["S"] = "s";
})(exports.KnownSignedResource || (exports.KnownSignedResource = {}));
/** Known values of {@link MigrationStatus} that the service accepts. */
exports.KnownMigrationStatus = void 0;
(function (KnownMigrationStatus) {
    /** Invalid */
    KnownMigrationStatus["Invalid"] = "Invalid";
    /** SubmittedForConversion */
    KnownMigrationStatus["SubmittedForConversion"] = "SubmittedForConversion";
    /** InProgress */
    KnownMigrationStatus["InProgress"] = "InProgress";
    /** Complete */
    KnownMigrationStatus["Complete"] = "Complete";
    /** Failed */
    KnownMigrationStatus["Failed"] = "Failed";
})(exports.KnownMigrationStatus || (exports.KnownMigrationStatus = {}));
/** Known values of {@link MigrationName} that the service accepts. */
exports.KnownMigrationName = void 0;
(function (KnownMigrationName) {
    /** Default */
    KnownMigrationName["Default"] = "default";
})(exports.KnownMigrationName || (exports.KnownMigrationName = {}));
/** Known values of {@link ManagementPolicyName} that the service accepts. */
exports.KnownManagementPolicyName = void 0;
(function (KnownManagementPolicyName) {
    /** Default */
    KnownManagementPolicyName["Default"] = "default";
})(exports.KnownManagementPolicyName || (exports.KnownManagementPolicyName = {}));
/** Known values of {@link RuleType} that the service accepts. */
exports.KnownRuleType = void 0;
(function (KnownRuleType) {
    /** Lifecycle */
    KnownRuleType["Lifecycle"] = "Lifecycle";
})(exports.KnownRuleType || (exports.KnownRuleType = {}));
/** Known values of {@link BlobInventoryPolicyName} that the service accepts. */
exports.KnownBlobInventoryPolicyName = void 0;
(function (KnownBlobInventoryPolicyName) {
    /** Default */
    KnownBlobInventoryPolicyName["Default"] = "default";
})(exports.KnownBlobInventoryPolicyName || (exports.KnownBlobInventoryPolicyName = {}));
/** Known values of {@link InventoryRuleType} that the service accepts. */
exports.KnownInventoryRuleType = void 0;
(function (KnownInventoryRuleType) {
    /** Inventory */
    KnownInventoryRuleType["Inventory"] = "Inventory";
})(exports.KnownInventoryRuleType || (exports.KnownInventoryRuleType = {}));
/** Known values of {@link Format} that the service accepts. */
exports.KnownFormat = void 0;
(function (KnownFormat) {
    /** Csv */
    KnownFormat["Csv"] = "Csv";
    /** Parquet */
    KnownFormat["Parquet"] = "Parquet";
})(exports.KnownFormat || (exports.KnownFormat = {}));
/** Known values of {@link Schedule} that the service accepts. */
exports.KnownSchedule = void 0;
(function (KnownSchedule) {
    /** Daily */
    KnownSchedule["Daily"] = "Daily";
    /** Weekly */
    KnownSchedule["Weekly"] = "Weekly";
})(exports.KnownSchedule || (exports.KnownSchedule = {}));
/** Known values of {@link ObjectType} that the service accepts. */
exports.KnownObjectType = void 0;
(function (KnownObjectType) {
    /** Blob */
    KnownObjectType["Blob"] = "Blob";
    /** Container */
    KnownObjectType["Container"] = "Container";
})(exports.KnownObjectType || (exports.KnownObjectType = {}));
/** Known values of {@link CreatedByType} that the service accepts. */
exports.KnownCreatedByType = void 0;
(function (KnownCreatedByType) {
    /** User */
    KnownCreatedByType["User"] = "User";
    /** Application */
    KnownCreatedByType["Application"] = "Application";
    /** ManagedIdentity */
    KnownCreatedByType["ManagedIdentity"] = "ManagedIdentity";
    /** Key */
    KnownCreatedByType["Key"] = "Key";
})(exports.KnownCreatedByType || (exports.KnownCreatedByType = {}));
/** Known values of {@link EncryptionScopeSource} that the service accepts. */
exports.KnownEncryptionScopeSource = void 0;
(function (KnownEncryptionScopeSource) {
    /** MicrosoftStorage */
    KnownEncryptionScopeSource["MicrosoftStorage"] = "Microsoft.Storage";
    /** MicrosoftKeyVault */
    KnownEncryptionScopeSource["MicrosoftKeyVault"] = "Microsoft.KeyVault";
})(exports.KnownEncryptionScopeSource || (exports.KnownEncryptionScopeSource = {}));
/** Known values of {@link EncryptionScopeState} that the service accepts. */
exports.KnownEncryptionScopeState = void 0;
(function (KnownEncryptionScopeState) {
    /** Enabled */
    KnownEncryptionScopeState["Enabled"] = "Enabled";
    /** Disabled */
    KnownEncryptionScopeState["Disabled"] = "Disabled";
})(exports.KnownEncryptionScopeState || (exports.KnownEncryptionScopeState = {}));
/** Known values of {@link ListEncryptionScopesInclude} that the service accepts. */
exports.KnownListEncryptionScopesInclude = void 0;
(function (KnownListEncryptionScopesInclude) {
    /** All */
    KnownListEncryptionScopesInclude["All"] = "All";
    /** Enabled */
    KnownListEncryptionScopesInclude["Enabled"] = "Enabled";
    /** Disabled */
    KnownListEncryptionScopesInclude["Disabled"] = "Disabled";
})(exports.KnownListEncryptionScopesInclude || (exports.KnownListEncryptionScopesInclude = {}));
/** Known values of {@link AllowedMethods} that the service accepts. */
exports.KnownAllowedMethods = void 0;
(function (KnownAllowedMethods) {
    /** Delete */
    KnownAllowedMethods["Delete"] = "DELETE";
    /** GET */
    KnownAllowedMethods["GET"] = "GET";
    /** Head */
    KnownAllowedMethods["Head"] = "HEAD";
    /** Merge */
    KnownAllowedMethods["Merge"] = "MERGE";
    /** Post */
    KnownAllowedMethods["Post"] = "POST";
    /** Options */
    KnownAllowedMethods["Options"] = "OPTIONS";
    /** PUT */
    KnownAllowedMethods["PUT"] = "PUT";
    /** Patch */
    KnownAllowedMethods["Patch"] = "PATCH";
    /** Connect */
    KnownAllowedMethods["Connect"] = "CONNECT";
    /** Trace */
    KnownAllowedMethods["Trace"] = "TRACE";
})(exports.KnownAllowedMethods || (exports.KnownAllowedMethods = {}));
/** Known values of {@link Name} that the service accepts. */
exports.KnownName = void 0;
(function (KnownName) {
    /** AccessTimeTracking */
    KnownName["AccessTimeTracking"] = "AccessTimeTracking";
})(exports.KnownName || (exports.KnownName = {}));
/** Known values of {@link ListContainersInclude} that the service accepts. */
exports.KnownListContainersInclude = void 0;
(function (KnownListContainersInclude) {
    /** Deleted */
    KnownListContainersInclude["Deleted"] = "deleted";
})(exports.KnownListContainersInclude || (exports.KnownListContainersInclude = {}));
/** Known values of {@link LeaseStatus} that the service accepts. */
exports.KnownLeaseStatus = void 0;
(function (KnownLeaseStatus) {
    /** Locked */
    KnownLeaseStatus["Locked"] = "Locked";
    /** Unlocked */
    KnownLeaseStatus["Unlocked"] = "Unlocked";
})(exports.KnownLeaseStatus || (exports.KnownLeaseStatus = {}));
/** Known values of {@link LeaseState} that the service accepts. */
exports.KnownLeaseState = void 0;
(function (KnownLeaseState) {
    /** Available */
    KnownLeaseState["Available"] = "Available";
    /** Leased */
    KnownLeaseState["Leased"] = "Leased";
    /** Expired */
    KnownLeaseState["Expired"] = "Expired";
    /** Breaking */
    KnownLeaseState["Breaking"] = "Breaking";
    /** Broken */
    KnownLeaseState["Broken"] = "Broken";
})(exports.KnownLeaseState || (exports.KnownLeaseState = {}));
/** Known values of {@link LeaseDuration} that the service accepts. */
exports.KnownLeaseDuration = void 0;
(function (KnownLeaseDuration) {
    /** Infinite */
    KnownLeaseDuration["Infinite"] = "Infinite";
    /** Fixed */
    KnownLeaseDuration["Fixed"] = "Fixed";
})(exports.KnownLeaseDuration || (exports.KnownLeaseDuration = {}));
/** Known values of {@link ImmutabilityPolicyState} that the service accepts. */
exports.KnownImmutabilityPolicyState = void 0;
(function (KnownImmutabilityPolicyState) {
    /** Locked */
    KnownImmutabilityPolicyState["Locked"] = "Locked";
    /** Unlocked */
    KnownImmutabilityPolicyState["Unlocked"] = "Unlocked";
})(exports.KnownImmutabilityPolicyState || (exports.KnownImmutabilityPolicyState = {}));
/** Known values of {@link ImmutabilityPolicyUpdateType} that the service accepts. */
exports.KnownImmutabilityPolicyUpdateType = void 0;
(function (KnownImmutabilityPolicyUpdateType) {
    /** Put */
    KnownImmutabilityPolicyUpdateType["Put"] = "put";
    /** Lock */
    KnownImmutabilityPolicyUpdateType["Lock"] = "lock";
    /** Extend */
    KnownImmutabilityPolicyUpdateType["Extend"] = "extend";
})(exports.KnownImmutabilityPolicyUpdateType || (exports.KnownImmutabilityPolicyUpdateType = {}));
/** Known values of {@link MigrationState} that the service accepts. */
exports.KnownMigrationState = void 0;
(function (KnownMigrationState) {
    /** InProgress */
    KnownMigrationState["InProgress"] = "InProgress";
    /** Completed */
    KnownMigrationState["Completed"] = "Completed";
})(exports.KnownMigrationState || (exports.KnownMigrationState = {}));
/** Known values of {@link LeaseContainerRequestAction} that the service accepts. */
exports.KnownLeaseContainerRequestAction = void 0;
(function (KnownLeaseContainerRequestAction) {
    /** Acquire */
    KnownLeaseContainerRequestAction["Acquire"] = "Acquire";
    /** Renew */
    KnownLeaseContainerRequestAction["Renew"] = "Renew";
    /** Change */
    KnownLeaseContainerRequestAction["Change"] = "Change";
    /** Release */
    KnownLeaseContainerRequestAction["Release"] = "Release";
    /** Break */
    KnownLeaseContainerRequestAction["Break"] = "Break";
})(exports.KnownLeaseContainerRequestAction || (exports.KnownLeaseContainerRequestAction = {}));
/** Known values of {@link EnabledProtocols} that the service accepts. */
exports.KnownEnabledProtocols = void 0;
(function (KnownEnabledProtocols) {
    /** SMB */
    KnownEnabledProtocols["SMB"] = "SMB";
    /** NFS */
    KnownEnabledProtocols["NFS"] = "NFS";
})(exports.KnownEnabledProtocols || (exports.KnownEnabledProtocols = {}));
/** Known values of {@link RootSquashType} that the service accepts. */
exports.KnownRootSquashType = void 0;
(function (KnownRootSquashType) {
    /** NoRootSquash */
    KnownRootSquashType["NoRootSquash"] = "NoRootSquash";
    /** RootSquash */
    KnownRootSquashType["RootSquash"] = "RootSquash";
    /** AllSquash */
    KnownRootSquashType["AllSquash"] = "AllSquash";
})(exports.KnownRootSquashType || (exports.KnownRootSquashType = {}));
/** Known values of {@link ShareAccessTier} that the service accepts. */
exports.KnownShareAccessTier = void 0;
(function (KnownShareAccessTier) {
    /** TransactionOptimized */
    KnownShareAccessTier["TransactionOptimized"] = "TransactionOptimized";
    /** Hot */
    KnownShareAccessTier["Hot"] = "Hot";
    /** Cool */
    KnownShareAccessTier["Cool"] = "Cool";
    /** Premium */
    KnownShareAccessTier["Premium"] = "Premium";
})(exports.KnownShareAccessTier || (exports.KnownShareAccessTier = {}));
/** Known values of {@link LeaseShareAction} that the service accepts. */
exports.KnownLeaseShareAction = void 0;
(function (KnownLeaseShareAction) {
    /** Acquire */
    KnownLeaseShareAction["Acquire"] = "Acquire";
    /** Renew */
    KnownLeaseShareAction["Renew"] = "Renew";
    /** Change */
    KnownLeaseShareAction["Change"] = "Change";
    /** Release */
    KnownLeaseShareAction["Release"] = "Release";
    /** Break */
    KnownLeaseShareAction["Break"] = "Break";
})(exports.KnownLeaseShareAction || (exports.KnownLeaseShareAction = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const OperationListResult = {
    type: {
        name: "Composite",
        className: "OperationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Operation"
                        }
                    }
                }
            }
        }
    }
};
const Operation = {
    type: {
        name: "Composite",
        className: "Operation",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "OperationDisplay"
                }
            },
            origin: {
                serializedName: "origin",
                type: {
                    name: "String"
                }
            },
            serviceSpecification: {
                serializedName: "properties.serviceSpecification",
                type: {
                    name: "Composite",
                    className: "ServiceSpecification"
                }
            }
        }
    }
};
const OperationDisplay = {
    type: {
        name: "Composite",
        className: "OperationDisplay",
        modelProperties: {
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceSpecification = {
    type: {
        name: "Composite",
        className: "ServiceSpecification",
        modelProperties: {
            metricSpecifications: {
                serializedName: "metricSpecifications",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricSpecification"
                        }
                    }
                }
            }
        }
    }
};
const MetricSpecification = {
    type: {
        name: "Composite",
        className: "MetricSpecification",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            displayDescription: {
                serializedName: "displayDescription",
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                type: {
                    name: "String"
                }
            },
            dimensions: {
                serializedName: "dimensions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Dimension"
                        }
                    }
                }
            },
            aggregationType: {
                serializedName: "aggregationType",
                type: {
                    name: "String"
                }
            },
            fillGapWithZero: {
                serializedName: "fillGapWithZero",
                type: {
                    name: "Boolean"
                }
            },
            category: {
                serializedName: "category",
                type: {
                    name: "String"
                }
            },
            resourceIdDimensionNameOverride: {
                serializedName: "resourceIdDimensionNameOverride",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Dimension = {
    type: {
        name: "Composite",
        className: "Dimension",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StorageSkuListResult = {
    type: {
        name: "Composite",
        className: "StorageSkuListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SkuInformation"
                        }
                    }
                }
            }
        }
    }
};
const SkuInformation = {
    type: {
        name: "Composite",
        className: "SkuInformation",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Standard", "Premium"]
                }
            },
            resourceType: {
                serializedName: "resourceType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            kind: {
                serializedName: "kind",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            locations: {
                serializedName: "locations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            capabilities: {
                serializedName: "capabilities",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SKUCapability"
                        }
                    }
                }
            },
            restrictions: {
                serializedName: "restrictions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Restriction"
                        }
                    }
                }
            }
        }
    }
};
const SKUCapability = {
    type: {
        name: "Composite",
        className: "SKUCapability",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Restriction = {
    type: {
        name: "Composite",
        className: "Restriction",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            values: {
                serializedName: "values",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            reasonCode: {
                serializedName: "reasonCode",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StorageAccountCheckNameAvailabilityParameters = {
    type: {
        name: "Composite",
        className: "StorageAccountCheckNameAvailabilityParameters",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            type: {
                defaultValue: "Microsoft.Storage/storageAccounts",
                isConstant: true,
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CheckNameAvailabilityResult = {
    type: {
        name: "Composite",
        className: "CheckNameAvailabilityResult",
        modelProperties: {
            nameAvailable: {
                serializedName: "nameAvailable",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            reason: {
                serializedName: "reason",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["AccountNameInvalid", "AlreadyExists"]
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StorageAccountCreateParameters = {
    type: {
        name: "Composite",
        className: "StorageAccountCreateParameters",
        modelProperties: {
            sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            },
            kind: {
                serializedName: "kind",
                required: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            },
            extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "Identity"
                }
            },
            allowedCopyScope: {
                serializedName: "properties.allowedCopyScope",
                type: {
                    name: "String"
                }
            },
            publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            },
            sasPolicy: {
                serializedName: "properties.sasPolicy",
                type: {
                    name: "Composite",
                    className: "SasPolicy"
                }
            },
            keyPolicy: {
                serializedName: "properties.keyPolicy",
                type: {
                    name: "Composite",
                    className: "KeyPolicy"
                }
            },
            customDomain: {
                serializedName: "properties.customDomain",
                type: {
                    name: "Composite",
                    className: "CustomDomain"
                }
            },
            encryption: {
                serializedName: "properties.encryption",
                type: {
                    name: "Composite",
                    className: "Encryption"
                }
            },
            networkRuleSet: {
                serializedName: "properties.networkAcls",
                type: {
                    name: "Composite",
                    className: "NetworkRuleSet"
                }
            },
            accessTier: {
                serializedName: "properties.accessTier",
                type: {
                    name: "Enum",
                    allowedValues: ["Hot", "Cool", "Premium"]
                }
            },
            azureFilesIdentityBasedAuthentication: {
                serializedName: "properties.azureFilesIdentityBasedAuthentication",
                type: {
                    name: "Composite",
                    className: "AzureFilesIdentityBasedAuthentication"
                }
            },
            enableHttpsTrafficOnly: {
                serializedName: "properties.supportsHttpsTrafficOnly",
                type: {
                    name: "Boolean"
                }
            },
            isSftpEnabled: {
                serializedName: "properties.isSftpEnabled",
                type: {
                    name: "Boolean"
                }
            },
            isLocalUserEnabled: {
                serializedName: "properties.isLocalUserEnabled",
                type: {
                    name: "Boolean"
                }
            },
            isHnsEnabled: {
                serializedName: "properties.isHnsEnabled",
                type: {
                    name: "Boolean"
                }
            },
            largeFileSharesState: {
                serializedName: "properties.largeFileSharesState",
                type: {
                    name: "String"
                }
            },
            routingPreference: {
                serializedName: "properties.routingPreference",
                type: {
                    name: "Composite",
                    className: "RoutingPreference"
                }
            },
            allowBlobPublicAccess: {
                serializedName: "properties.allowBlobPublicAccess",
                type: {
                    name: "Boolean"
                }
            },
            minimumTlsVersion: {
                serializedName: "properties.minimumTlsVersion",
                type: {
                    name: "String"
                }
            },
            allowSharedKeyAccess: {
                serializedName: "properties.allowSharedKeyAccess",
                type: {
                    name: "Boolean"
                }
            },
            enableNfsV3: {
                serializedName: "properties.isNfsV3Enabled",
                type: {
                    name: "Boolean"
                }
            },
            allowCrossTenantReplication: {
                serializedName: "properties.allowCrossTenantReplication",
                type: {
                    name: "Boolean"
                }
            },
            defaultToOAuthAuthentication: {
                serializedName: "properties.defaultToOAuthAuthentication",
                type: {
                    name: "Boolean"
                }
            },
            immutableStorageWithVersioning: {
                serializedName: "properties.immutableStorageWithVersioning",
                type: {
                    name: "Composite",
                    className: "ImmutableStorageAccount"
                }
            },
            dnsEndpointType: {
                serializedName: "properties.dnsEndpointType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Sku = {
    type: {
        name: "Composite",
        className: "Sku",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Standard", "Premium"]
                }
            }
        }
    }
};
const ExtendedLocation = {
    type: {
        name: "Composite",
        className: "ExtendedLocation",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Identity = {
    type: {
        name: "Composite",
        className: "Identity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "UserAssignedIdentity" }
                    }
                }
            }
        }
    }
};
const UserAssignedIdentity = {
    type: {
        name: "Composite",
        className: "UserAssignedIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            clientId: {
                serializedName: "clientId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SasPolicy = {
    type: {
        name: "Composite",
        className: "SasPolicy",
        modelProperties: {
            sasExpirationPeriod: {
                serializedName: "sasExpirationPeriod",
                required: true,
                type: {
                    name: "String"
                }
            },
            expirationAction: {
                defaultValue: "Log",
                serializedName: "expirationAction",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KeyPolicy = {
    type: {
        name: "Composite",
        className: "KeyPolicy",
        modelProperties: {
            keyExpirationPeriodInDays: {
                serializedName: "keyExpirationPeriodInDays",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const CustomDomain = {
    type: {
        name: "Composite",
        className: "CustomDomain",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            useSubDomainName: {
                serializedName: "useSubDomainName",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const Encryption = {
    type: {
        name: "Composite",
        className: "Encryption",
        modelProperties: {
            services: {
                serializedName: "services",
                type: {
                    name: "Composite",
                    className: "EncryptionServices"
                }
            },
            keySource: {
                defaultValue: "Microsoft.Storage",
                serializedName: "keySource",
                type: {
                    name: "String"
                }
            },
            requireInfrastructureEncryption: {
                serializedName: "requireInfrastructureEncryption",
                type: {
                    name: "Boolean"
                }
            },
            keyVaultProperties: {
                serializedName: "keyvaultproperties",
                type: {
                    name: "Composite",
                    className: "KeyVaultProperties"
                }
            },
            encryptionIdentity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "EncryptionIdentity"
                }
            }
        }
    }
};
const EncryptionServices = {
    type: {
        name: "Composite",
        className: "EncryptionServices",
        modelProperties: {
            blob: {
                serializedName: "blob",
                type: {
                    name: "Composite",
                    className: "EncryptionService"
                }
            },
            file: {
                serializedName: "file",
                type: {
                    name: "Composite",
                    className: "EncryptionService"
                }
            },
            table: {
                serializedName: "table",
                type: {
                    name: "Composite",
                    className: "EncryptionService"
                }
            },
            queue: {
                serializedName: "queue",
                type: {
                    name: "Composite",
                    className: "EncryptionService"
                }
            }
        }
    }
};
const EncryptionService = {
    type: {
        name: "Composite",
        className: "EncryptionService",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            lastEnabledTime: {
                serializedName: "lastEnabledTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            keyType: {
                serializedName: "keyType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KeyVaultProperties = {
    type: {
        name: "Composite",
        className: "KeyVaultProperties",
        modelProperties: {
            keyName: {
                serializedName: "keyname",
                type: {
                    name: "String"
                }
            },
            keyVersion: {
                serializedName: "keyversion",
                type: {
                    name: "String"
                }
            },
            keyVaultUri: {
                serializedName: "keyvaulturi",
                type: {
                    name: "String"
                }
            },
            currentVersionedKeyIdentifier: {
                serializedName: "currentVersionedKeyIdentifier",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            lastKeyRotationTimestamp: {
                serializedName: "lastKeyRotationTimestamp",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            currentVersionedKeyExpirationTimestamp: {
                serializedName: "currentVersionedKeyExpirationTimestamp",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const EncryptionIdentity = {
    type: {
        name: "Composite",
        className: "EncryptionIdentity",
        modelProperties: {
            encryptionUserAssignedIdentity: {
                serializedName: "userAssignedIdentity",
                type: {
                    name: "String"
                }
            },
            encryptionFederatedIdentityClientId: {
                serializedName: "federatedIdentityClientId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkRuleSet = {
    type: {
        name: "Composite",
        className: "NetworkRuleSet",
        modelProperties: {
            bypass: {
                defaultValue: "AzureServices",
                serializedName: "bypass",
                type: {
                    name: "String"
                }
            },
            resourceAccessRules: {
                serializedName: "resourceAccessRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceAccessRule"
                        }
                    }
                }
            },
            virtualNetworkRules: {
                serializedName: "virtualNetworkRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetworkRule"
                        }
                    }
                }
            },
            ipRules: {
                serializedName: "ipRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IPRule"
                        }
                    }
                }
            },
            defaultAction: {
                defaultValue: "Allow",
                serializedName: "defaultAction",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Allow", "Deny"]
                }
            }
        }
    }
};
const ResourceAccessRule = {
    type: {
        name: "Composite",
        className: "ResourceAccessRule",
        modelProperties: {
            tenantId: {
                serializedName: "tenantId",
                type: {
                    name: "String"
                }
            },
            resourceId: {
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetworkRule = {
    type: {
        name: "Composite",
        className: "VirtualNetworkRule",
        modelProperties: {
            virtualNetworkResourceId: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            action: {
                defaultValue: "Allow",
                isConstant: true,
                serializedName: "action",
                type: {
                    name: "String"
                }
            },
            state: {
                serializedName: "state",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IPRule = {
    type: {
        name: "Composite",
        className: "IPRule",
        modelProperties: {
            iPAddressOrRange: {
                serializedName: "value",
                required: true,
                type: {
                    name: "String"
                }
            },
            action: {
                defaultValue: "Allow",
                isConstant: true,
                serializedName: "action",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureFilesIdentityBasedAuthentication = {
    type: {
        name: "Composite",
        className: "AzureFilesIdentityBasedAuthentication",
        modelProperties: {
            directoryServiceOptions: {
                serializedName: "directoryServiceOptions",
                required: true,
                type: {
                    name: "String"
                }
            },
            activeDirectoryProperties: {
                serializedName: "activeDirectoryProperties",
                type: {
                    name: "Composite",
                    className: "ActiveDirectoryProperties"
                }
            },
            defaultSharePermission: {
                serializedName: "defaultSharePermission",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ActiveDirectoryProperties = {
    type: {
        name: "Composite",
        className: "ActiveDirectoryProperties",
        modelProperties: {
            domainName: {
                serializedName: "domainName",
                required: true,
                type: {
                    name: "String"
                }
            },
            netBiosDomainName: {
                serializedName: "netBiosDomainName",
                type: {
                    name: "String"
                }
            },
            forestName: {
                serializedName: "forestName",
                type: {
                    name: "String"
                }
            },
            domainGuid: {
                serializedName: "domainGuid",
                required: true,
                type: {
                    name: "String"
                }
            },
            domainSid: {
                serializedName: "domainSid",
                type: {
                    name: "String"
                }
            },
            azureStorageSid: {
                serializedName: "azureStorageSid",
                type: {
                    name: "String"
                }
            },
            samAccountName: {
                serializedName: "samAccountName",
                type: {
                    name: "String"
                }
            },
            accountType: {
                serializedName: "accountType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoutingPreference = {
    type: {
        name: "Composite",
        className: "RoutingPreference",
        modelProperties: {
            routingChoice: {
                serializedName: "routingChoice",
                type: {
                    name: "String"
                }
            },
            publishMicrosoftEndpoints: {
                serializedName: "publishMicrosoftEndpoints",
                type: {
                    name: "Boolean"
                }
            },
            publishInternetEndpoints: {
                serializedName: "publishInternetEndpoints",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ImmutableStorageAccount = {
    type: {
        name: "Composite",
        className: "ImmutableStorageAccount",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            immutabilityPolicy: {
                serializedName: "immutabilityPolicy",
                type: {
                    name: "Composite",
                    className: "AccountImmutabilityPolicyProperties"
                }
            }
        }
    }
};
const AccountImmutabilityPolicyProperties = {
    type: {
        name: "Composite",
        className: "AccountImmutabilityPolicyProperties",
        modelProperties: {
            immutabilityPeriodSinceCreationInDays: {
                constraints: {
                    InclusiveMaximum: 146000,
                    InclusiveMinimum: 1
                },
                serializedName: "immutabilityPeriodSinceCreationInDays",
                type: {
                    name: "Number"
                }
            },
            state: {
                serializedName: "state",
                type: {
                    name: "String"
                }
            },
            allowProtectedAppendWrites: {
                serializedName: "allowProtectedAppendWrites",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const Endpoints = {
    type: {
        name: "Composite",
        className: "Endpoints",
        modelProperties: {
            blob: {
                serializedName: "blob",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            queue: {
                serializedName: "queue",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            table: {
                serializedName: "table",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            file: {
                serializedName: "file",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            web: {
                serializedName: "web",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            dfs: {
                serializedName: "dfs",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            microsoftEndpoints: {
                serializedName: "microsoftEndpoints",
                type: {
                    name: "Composite",
                    className: "StorageAccountMicrosoftEndpoints"
                }
            },
            internetEndpoints: {
                serializedName: "internetEndpoints",
                type: {
                    name: "Composite",
                    className: "StorageAccountInternetEndpoints"
                }
            }
        }
    }
};
const StorageAccountMicrosoftEndpoints = {
    type: {
        name: "Composite",
        className: "StorageAccountMicrosoftEndpoints",
        modelProperties: {
            blob: {
                serializedName: "blob",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            queue: {
                serializedName: "queue",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            table: {
                serializedName: "table",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            file: {
                serializedName: "file",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            web: {
                serializedName: "web",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            dfs: {
                serializedName: "dfs",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StorageAccountInternetEndpoints = {
    type: {
        name: "Composite",
        className: "StorageAccountInternetEndpoints",
        modelProperties: {
            blob: {
                serializedName: "blob",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            file: {
                serializedName: "file",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            web: {
                serializedName: "web",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            dfs: {
                serializedName: "dfs",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KeyCreationTime = {
    type: {
        name: "Composite",
        className: "KeyCreationTime",
        modelProperties: {
            key1: {
                serializedName: "key1",
                type: {
                    name: "DateTime"
                }
            },
            key2: {
                serializedName: "key2",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const GeoReplicationStats = {
    type: {
        name: "Composite",
        className: "GeoReplicationStats",
        modelProperties: {
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            lastSyncTime: {
                serializedName: "lastSyncTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            canFailover: {
                serializedName: "canFailover",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            canPlannedFailover: {
                serializedName: "canPlannedFailover",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            postFailoverRedundancy: {
                serializedName: "postFailoverRedundancy",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            postPlannedFailoverRedundancy: {
                serializedName: "postPlannedFailoverRedundancy",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpoint = {
    type: {
        name: "Composite",
        className: "PrivateEndpoint",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkServiceConnectionState = {
    type: {
        name: "Composite",
        className: "PrivateLinkServiceConnectionState",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            actionRequired: {
                serializedName: "actionRequired",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BlobRestoreStatus = {
    type: {
        name: "Composite",
        className: "BlobRestoreStatus",
        modelProperties: {
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            failureReason: {
                serializedName: "failureReason",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            restoreId: {
                serializedName: "restoreId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "BlobRestoreParameters"
                }
            }
        }
    }
};
const BlobRestoreParameters = {
    type: {
        name: "Composite",
        className: "BlobRestoreParameters",
        modelProperties: {
            timeToRestore: {
                serializedName: "timeToRestore",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            blobRanges: {
                serializedName: "blobRanges",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BlobRestoreRange"
                        }
                    }
                }
            }
        }
    }
};
const BlobRestoreRange = {
    type: {
        name: "Composite",
        className: "BlobRestoreRange",
        modelProperties: {
            startRange: {
                serializedName: "startRange",
                required: true,
                type: {
                    name: "String"
                }
            },
            endRange: {
                serializedName: "endRange",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StorageAccountSkuConversionStatus = {
    type: {
        name: "Composite",
        className: "StorageAccountSkuConversionStatus",
        modelProperties: {
            skuConversionStatus: {
                serializedName: "skuConversionStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            targetSkuName: {
                serializedName: "targetSkuName",
                type: {
                    name: "String"
                }
            },
            startTime: {
                serializedName: "startTime",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            endTime: {
                serializedName: "endTime",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StorageAccountUpdateParameters = {
    type: {
        name: "Composite",
        className: "StorageAccountUpdateParameters",
        modelProperties: {
            sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "Identity"
                }
            },
            kind: {
                serializedName: "kind",
                type: {
                    name: "String"
                }
            },
            customDomain: {
                serializedName: "properties.customDomain",
                type: {
                    name: "Composite",
                    className: "CustomDomain"
                }
            },
            encryption: {
                serializedName: "properties.encryption",
                type: {
                    name: "Composite",
                    className: "Encryption"
                }
            },
            sasPolicy: {
                serializedName: "properties.sasPolicy",
                type: {
                    name: "Composite",
                    className: "SasPolicy"
                }
            },
            keyPolicy: {
                serializedName: "properties.keyPolicy",
                type: {
                    name: "Composite",
                    className: "KeyPolicy"
                }
            },
            accessTier: {
                serializedName: "properties.accessTier",
                type: {
                    name: "Enum",
                    allowedValues: ["Hot", "Cool", "Premium"]
                }
            },
            azureFilesIdentityBasedAuthentication: {
                serializedName: "properties.azureFilesIdentityBasedAuthentication",
                type: {
                    name: "Composite",
                    className: "AzureFilesIdentityBasedAuthentication"
                }
            },
            enableHttpsTrafficOnly: {
                serializedName: "properties.supportsHttpsTrafficOnly",
                type: {
                    name: "Boolean"
                }
            },
            isSftpEnabled: {
                serializedName: "properties.isSftpEnabled",
                type: {
                    name: "Boolean"
                }
            },
            isLocalUserEnabled: {
                serializedName: "properties.isLocalUserEnabled",
                type: {
                    name: "Boolean"
                }
            },
            networkRuleSet: {
                serializedName: "properties.networkAcls",
                type: {
                    name: "Composite",
                    className: "NetworkRuleSet"
                }
            },
            largeFileSharesState: {
                serializedName: "properties.largeFileSharesState",
                type: {
                    name: "String"
                }
            },
            routingPreference: {
                serializedName: "properties.routingPreference",
                type: {
                    name: "Composite",
                    className: "RoutingPreference"
                }
            },
            allowBlobPublicAccess: {
                serializedName: "properties.allowBlobPublicAccess",
                type: {
                    name: "Boolean"
                }
            },
            minimumTlsVersion: {
                serializedName: "properties.minimumTlsVersion",
                type: {
                    name: "String"
                }
            },
            allowSharedKeyAccess: {
                serializedName: "properties.allowSharedKeyAccess",
                type: {
                    name: "Boolean"
                }
            },
            allowCrossTenantReplication: {
                serializedName: "properties.allowCrossTenantReplication",
                type: {
                    name: "Boolean"
                }
            },
            defaultToOAuthAuthentication: {
                serializedName: "properties.defaultToOAuthAuthentication",
                type: {
                    name: "Boolean"
                }
            },
            publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            },
            immutableStorageWithVersioning: {
                serializedName: "properties.immutableStorageWithVersioning",
                type: {
                    name: "Composite",
                    className: "ImmutableStorageAccount"
                }
            },
            allowedCopyScope: {
                serializedName: "properties.allowedCopyScope",
                type: {
                    name: "String"
                }
            },
            dnsEndpointType: {
                serializedName: "properties.dnsEndpointType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeletedAccountListResult = {
    type: {
        name: "Composite",
        className: "DeletedAccountListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeletedAccount"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorResponseBody"
                }
            }
        }
    }
};
const ErrorResponseBody = {
    type: {
        name: "Composite",
        className: "ErrorResponseBody",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StorageAccountListResult = {
    type: {
        name: "Composite",
        className: "StorageAccountListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StorageAccount"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StorageAccountListKeysResult = {
    type: {
        name: "Composite",
        className: "StorageAccountListKeysResult",
        modelProperties: {
            keys: {
                serializedName: "keys",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StorageAccountKey"
                        }
                    }
                }
            }
        }
    }
};
const StorageAccountKey = {
    type: {
        name: "Composite",
        className: "StorageAccountKey",
        modelProperties: {
            keyName: {
                serializedName: "keyName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            permissions: {
                serializedName: "permissions",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Read", "Full"]
                }
            },
            creationTime: {
                serializedName: "creationTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const StorageAccountRegenerateKeyParameters = {
    type: {
        name: "Composite",
        className: "StorageAccountRegenerateKeyParameters",
        modelProperties: {
            keyName: {
                serializedName: "keyName",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UsageListResult = {
    type: {
        name: "Composite",
        className: "UsageListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Usage"
                        }
                    }
                }
            }
        }
    }
};
const Usage = {
    type: {
        name: "Composite",
        className: "Usage",
        modelProperties: {
            unit: {
                serializedName: "unit",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Count",
                        "Bytes",
                        "Seconds",
                        "Percent",
                        "CountsPerSecond",
                        "BytesPerSecond"
                    ]
                }
            },
            currentValue: {
                serializedName: "currentValue",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            limit: {
                serializedName: "limit",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "Composite",
                    className: "UsageName"
                }
            }
        }
    }
};
const UsageName = {
    type: {
        name: "Composite",
        className: "UsageName",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            localizedValue: {
                serializedName: "localizedValue",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AccountSasParameters = {
    type: {
        name: "Composite",
        className: "AccountSasParameters",
        modelProperties: {
            services: {
                serializedName: "signedServices",
                required: true,
                type: {
                    name: "String"
                }
            },
            resourceTypes: {
                serializedName: "signedResourceTypes",
                required: true,
                type: {
                    name: "String"
                }
            },
            permissions: {
                serializedName: "signedPermission",
                required: true,
                type: {
                    name: "String"
                }
            },
            iPAddressOrRange: {
                serializedName: "signedIp",
                type: {
                    name: "String"
                }
            },
            protocols: {
                serializedName: "signedProtocol",
                type: {
                    name: "Enum",
                    allowedValues: ["https,http", "https"]
                }
            },
            sharedAccessStartTime: {
                serializedName: "signedStart",
                type: {
                    name: "DateTime"
                }
            },
            sharedAccessExpiryTime: {
                serializedName: "signedExpiry",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            keyToSign: {
                serializedName: "keyToSign",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListAccountSasResponse = {
    type: {
        name: "Composite",
        className: "ListAccountSasResponse",
        modelProperties: {
            accountSasToken: {
                serializedName: "accountSasToken",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceSasParameters = {
    type: {
        name: "Composite",
        className: "ServiceSasParameters",
        modelProperties: {
            canonicalizedResource: {
                serializedName: "canonicalizedResource",
                required: true,
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "signedResource",
                type: {
                    name: "String"
                }
            },
            permissions: {
                serializedName: "signedPermission",
                type: {
                    name: "String"
                }
            },
            iPAddressOrRange: {
                serializedName: "signedIp",
                type: {
                    name: "String"
                }
            },
            protocols: {
                serializedName: "signedProtocol",
                type: {
                    name: "Enum",
                    allowedValues: ["https,http", "https"]
                }
            },
            sharedAccessStartTime: {
                serializedName: "signedStart",
                type: {
                    name: "DateTime"
                }
            },
            sharedAccessExpiryTime: {
                serializedName: "signedExpiry",
                type: {
                    name: "DateTime"
                }
            },
            identifier: {
                constraints: {
                    MaxLength: 64
                },
                serializedName: "signedIdentifier",
                type: {
                    name: "String"
                }
            },
            partitionKeyStart: {
                serializedName: "startPk",
                type: {
                    name: "String"
                }
            },
            partitionKeyEnd: {
                serializedName: "endPk",
                type: {
                    name: "String"
                }
            },
            rowKeyStart: {
                serializedName: "startRk",
                type: {
                    name: "String"
                }
            },
            rowKeyEnd: {
                serializedName: "endRk",
                type: {
                    name: "String"
                }
            },
            keyToSign: {
                serializedName: "keyToSign",
                type: {
                    name: "String"
                }
            },
            cacheControl: {
                serializedName: "rscc",
                type: {
                    name: "String"
                }
            },
            contentDisposition: {
                serializedName: "rscd",
                type: {
                    name: "String"
                }
            },
            contentEncoding: {
                serializedName: "rsce",
                type: {
                    name: "String"
                }
            },
            contentLanguage: {
                serializedName: "rscl",
                type: {
                    name: "String"
                }
            },
            contentType: {
                serializedName: "rsct",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListServiceSasResponse = {
    type: {
        name: "Composite",
        className: "ListServiceSasResponse",
        modelProperties: {
            serviceSasToken: {
                serializedName: "serviceSasToken",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StorageAccountMigration = {
    type: {
        name: "Composite",
        className: "StorageAccountMigration",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            targetSkuName: {
                serializedName: "properties.targetSkuName",
                required: true,
                type: {
                    name: "String"
                }
            },
            migrationStatus: {
                serializedName: "properties.migrationStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            migrationFailedReason: {
                serializedName: "properties.migrationFailedReason",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            migrationFailedDetailedReason: {
                serializedName: "properties.migrationFailedDetailedReason",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ErrorResponseAutoGenerated = {
    type: {
        name: "Composite",
        className: "ErrorResponseAutoGenerated",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorDetail"
                }
            }
        }
    }
};
const ErrorDetail = {
    type: {
        name: "Composite",
        className: "ErrorDetail",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorDetail"
                        }
                    }
                }
            },
            additionalInfo: {
                serializedName: "additionalInfo",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorAdditionalInfo"
                        }
                    }
                }
            }
        }
    }
};
const ErrorAdditionalInfo = {
    type: {
        name: "Composite",
        className: "ErrorAdditionalInfo",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            info: {
                serializedName: "info",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const ManagementPolicySchema = {
    type: {
        name: "Composite",
        className: "ManagementPolicySchema",
        modelProperties: {
            rules: {
                serializedName: "rules",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagementPolicyRule"
                        }
                    }
                }
            }
        }
    }
};
const ManagementPolicyRule = {
    type: {
        name: "Composite",
        className: "ManagementPolicyRule",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            definition: {
                serializedName: "definition",
                type: {
                    name: "Composite",
                    className: "ManagementPolicyDefinition"
                }
            }
        }
    }
};
const ManagementPolicyDefinition = {
    type: {
        name: "Composite",
        className: "ManagementPolicyDefinition",
        modelProperties: {
            actions: {
                serializedName: "actions",
                type: {
                    name: "Composite",
                    className: "ManagementPolicyAction"
                }
            },
            filters: {
                serializedName: "filters",
                type: {
                    name: "Composite",
                    className: "ManagementPolicyFilter"
                }
            }
        }
    }
};
const ManagementPolicyAction = {
    type: {
        name: "Composite",
        className: "ManagementPolicyAction",
        modelProperties: {
            baseBlob: {
                serializedName: "baseBlob",
                type: {
                    name: "Composite",
                    className: "ManagementPolicyBaseBlob"
                }
            },
            snapshot: {
                serializedName: "snapshot",
                type: {
                    name: "Composite",
                    className: "ManagementPolicySnapShot"
                }
            },
            version: {
                serializedName: "version",
                type: {
                    name: "Composite",
                    className: "ManagementPolicyVersion"
                }
            }
        }
    }
};
const ManagementPolicyBaseBlob = {
    type: {
        name: "Composite",
        className: "ManagementPolicyBaseBlob",
        modelProperties: {
            tierToCool: {
                serializedName: "tierToCool",
                type: {
                    name: "Composite",
                    className: "DateAfterModification"
                }
            },
            tierToArchive: {
                serializedName: "tierToArchive",
                type: {
                    name: "Composite",
                    className: "DateAfterModification"
                }
            },
            tierToCold: {
                serializedName: "tierToCold",
                type: {
                    name: "Composite",
                    className: "DateAfterModification"
                }
            },
            tierToHot: {
                serializedName: "tierToHot",
                type: {
                    name: "Composite",
                    className: "DateAfterModification"
                }
            },
            delete: {
                serializedName: "delete",
                type: {
                    name: "Composite",
                    className: "DateAfterModification"
                }
            },
            enableAutoTierToHotFromCool: {
                serializedName: "enableAutoTierToHotFromCool",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const DateAfterModification = {
    type: {
        name: "Composite",
        className: "DateAfterModification",
        modelProperties: {
            daysAfterModificationGreaterThan: {
                constraints: {
                    InclusiveMinimum: 0,
                    MultipleOf: 1
                },
                serializedName: "daysAfterModificationGreaterThan",
                type: {
                    name: "Number"
                }
            },
            daysAfterLastAccessTimeGreaterThan: {
                constraints: {
                    InclusiveMinimum: 0,
                    MultipleOf: 1
                },
                serializedName: "daysAfterLastAccessTimeGreaterThan",
                type: {
                    name: "Number"
                }
            },
            daysAfterLastTierChangeGreaterThan: {
                constraints: {
                    InclusiveMinimum: 0,
                    MultipleOf: 1
                },
                serializedName: "daysAfterLastTierChangeGreaterThan",
                type: {
                    name: "Number"
                }
            },
            daysAfterCreationGreaterThan: {
                constraints: {
                    InclusiveMinimum: 0,
                    MultipleOf: 1
                },
                serializedName: "daysAfterCreationGreaterThan",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ManagementPolicySnapShot = {
    type: {
        name: "Composite",
        className: "ManagementPolicySnapShot",
        modelProperties: {
            tierToCool: {
                serializedName: "tierToCool",
                type: {
                    name: "Composite",
                    className: "DateAfterCreation"
                }
            },
            tierToArchive: {
                serializedName: "tierToArchive",
                type: {
                    name: "Composite",
                    className: "DateAfterCreation"
                }
            },
            tierToCold: {
                serializedName: "tierToCold",
                type: {
                    name: "Composite",
                    className: "DateAfterCreation"
                }
            },
            tierToHot: {
                serializedName: "tierToHot",
                type: {
                    name: "Composite",
                    className: "DateAfterCreation"
                }
            },
            delete: {
                serializedName: "delete",
                type: {
                    name: "Composite",
                    className: "DateAfterCreation"
                }
            }
        }
    }
};
const DateAfterCreation = {
    type: {
        name: "Composite",
        className: "DateAfterCreation",
        modelProperties: {
            daysAfterCreationGreaterThan: {
                constraints: {
                    InclusiveMinimum: 0,
                    MultipleOf: 1
                },
                serializedName: "daysAfterCreationGreaterThan",
                required: true,
                type: {
                    name: "Number"
                }
            },
            daysAfterLastTierChangeGreaterThan: {
                constraints: {
                    InclusiveMinimum: 0,
                    MultipleOf: 1
                },
                serializedName: "daysAfterLastTierChangeGreaterThan",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ManagementPolicyVersion = {
    type: {
        name: "Composite",
        className: "ManagementPolicyVersion",
        modelProperties: {
            tierToCool: {
                serializedName: "tierToCool",
                type: {
                    name: "Composite",
                    className: "DateAfterCreation"
                }
            },
            tierToArchive: {
                serializedName: "tierToArchive",
                type: {
                    name: "Composite",
                    className: "DateAfterCreation"
                }
            },
            tierToCold: {
                serializedName: "tierToCold",
                type: {
                    name: "Composite",
                    className: "DateAfterCreation"
                }
            },
            tierToHot: {
                serializedName: "tierToHot",
                type: {
                    name: "Composite",
                    className: "DateAfterCreation"
                }
            },
            delete: {
                serializedName: "delete",
                type: {
                    name: "Composite",
                    className: "DateAfterCreation"
                }
            }
        }
    }
};
const ManagementPolicyFilter = {
    type: {
        name: "Composite",
        className: "ManagementPolicyFilter",
        modelProperties: {
            prefixMatch: {
                serializedName: "prefixMatch",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            blobTypes: {
                serializedName: "blobTypes",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            blobIndexMatch: {
                serializedName: "blobIndexMatch",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TagFilter"
                        }
                    }
                }
            }
        }
    }
};
const TagFilter = {
    type: {
        name: "Composite",
        className: "TagFilter",
        modelProperties: {
            name: {
                constraints: {
                    MaxLength: 128,
                    MinLength: 1
                },
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            op: {
                serializedName: "op",
                required: true,
                type: {
                    name: "String"
                }
            },
            value: {
                constraints: {
                    MaxLength: 256
                },
                serializedName: "value",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BlobInventoryPolicySchema = {
    type: {
        name: "Composite",
        className: "BlobInventoryPolicySchema",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            destination: {
                serializedName: "destination",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            rules: {
                serializedName: "rules",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BlobInventoryPolicyRule"
                        }
                    }
                }
            }
        }
    }
};
const BlobInventoryPolicyRule = {
    type: {
        name: "Composite",
        className: "BlobInventoryPolicyRule",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            destination: {
                serializedName: "destination",
                required: true,
                type: {
                    name: "String"
                }
            },
            definition: {
                serializedName: "definition",
                type: {
                    name: "Composite",
                    className: "BlobInventoryPolicyDefinition"
                }
            }
        }
    }
};
const BlobInventoryPolicyDefinition = {
    type: {
        name: "Composite",
        className: "BlobInventoryPolicyDefinition",
        modelProperties: {
            filters: {
                serializedName: "filters",
                type: {
                    name: "Composite",
                    className: "BlobInventoryPolicyFilter"
                }
            },
            format: {
                serializedName: "format",
                required: true,
                type: {
                    name: "String"
                }
            },
            schedule: {
                serializedName: "schedule",
                required: true,
                type: {
                    name: "String"
                }
            },
            objectType: {
                serializedName: "objectType",
                required: true,
                type: {
                    name: "String"
                }
            },
            schemaFields: {
                serializedName: "schemaFields",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const BlobInventoryPolicyFilter = {
    type: {
        name: "Composite",
        className: "BlobInventoryPolicyFilter",
        modelProperties: {
            prefixMatch: {
                serializedName: "prefixMatch",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            excludePrefix: {
                serializedName: "excludePrefix",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            blobTypes: {
                serializedName: "blobTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            includeBlobVersions: {
                serializedName: "includeBlobVersions",
                type: {
                    name: "Boolean"
                }
            },
            includeSnapshots: {
                serializedName: "includeSnapshots",
                type: {
                    name: "Boolean"
                }
            },
            includeDeleted: {
                serializedName: "includeDeleted",
                type: {
                    name: "Boolean"
                }
            },
            creationTime: {
                serializedName: "creationTime",
                type: {
                    name: "Composite",
                    className: "BlobInventoryCreationTime"
                }
            }
        }
    }
};
const BlobInventoryCreationTime = {
    type: {
        name: "Composite",
        className: "BlobInventoryCreationTime",
        modelProperties: {
            lastNDays: {
                constraints: {
                    InclusiveMaximum: 36500,
                    InclusiveMinimum: 1
                },
                serializedName: "lastNDays",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SystemData = {
    type: {
        name: "Composite",
        className: "SystemData",
        modelProperties: {
            createdBy: {
                serializedName: "createdBy",
                type: {
                    name: "String"
                }
            },
            createdByType: {
                serializedName: "createdByType",
                type: {
                    name: "String"
                }
            },
            createdAt: {
                serializedName: "createdAt",
                type: {
                    name: "DateTime"
                }
            },
            lastModifiedBy: {
                serializedName: "lastModifiedBy",
                type: {
                    name: "String"
                }
            },
            lastModifiedByType: {
                serializedName: "lastModifiedByType",
                type: {
                    name: "String"
                }
            },
            lastModifiedAt: {
                serializedName: "lastModifiedAt",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const CloudError = {
    type: {
        name: "Composite",
        className: "CloudError",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "CloudErrorBody"
                }
            }
        }
    }
};
const CloudErrorBody = {
    type: {
        name: "Composite",
        className: "CloudErrorBody",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CloudErrorBody"
                        }
                    }
                }
            }
        }
    }
};
const ListBlobInventoryPolicy = {
    type: {
        name: "Composite",
        className: "ListBlobInventoryPolicy",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BlobInventoryPolicy"
                        }
                    }
                }
            }
        }
    }
};
const PrivateEndpointConnectionListResult = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            }
        }
    }
};
const PrivateLinkResourceListResult = {
    type: {
        name: "Composite",
        className: "PrivateLinkResourceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateLinkResource"
                        }
                    }
                }
            }
        }
    }
};
const ObjectReplicationPolicies = {
    type: {
        name: "Composite",
        className: "ObjectReplicationPolicies",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ObjectReplicationPolicy"
                        }
                    }
                }
            }
        }
    }
};
const ObjectReplicationPolicyRule = {
    type: {
        name: "Composite",
        className: "ObjectReplicationPolicyRule",
        modelProperties: {
            ruleId: {
                serializedName: "ruleId",
                type: {
                    name: "String"
                }
            },
            sourceContainer: {
                serializedName: "sourceContainer",
                required: true,
                type: {
                    name: "String"
                }
            },
            destinationContainer: {
                serializedName: "destinationContainer",
                required: true,
                type: {
                    name: "String"
                }
            },
            filters: {
                serializedName: "filters",
                type: {
                    name: "Composite",
                    className: "ObjectReplicationPolicyFilter"
                }
            }
        }
    }
};
const ObjectReplicationPolicyFilter = {
    type: {
        name: "Composite",
        className: "ObjectReplicationPolicyFilter",
        modelProperties: {
            prefixMatch: {
                serializedName: "prefixMatch",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            minCreationTime: {
                serializedName: "minCreationTime",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LocalUsers = {
    type: {
        name: "Composite",
        className: "LocalUsers",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LocalUser"
                        }
                    }
                }
            }
        }
    }
};
const PermissionScope = {
    type: {
        name: "Composite",
        className: "PermissionScope",
        modelProperties: {
            permissions: {
                serializedName: "permissions",
                required: true,
                type: {
                    name: "String"
                }
            },
            service: {
                serializedName: "service",
                required: true,
                type: {
                    name: "String"
                }
            },
            resourceName: {
                serializedName: "resourceName",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SshPublicKey = {
    type: {
        name: "Composite",
        className: "SshPublicKey",
        modelProperties: {
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            key: {
                serializedName: "key",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LocalUserKeys = {
    type: {
        name: "Composite",
        className: "LocalUserKeys",
        modelProperties: {
            sshAuthorizedKeys: {
                serializedName: "sshAuthorizedKeys",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SshPublicKey"
                        }
                    }
                }
            },
            sharedKey: {
                serializedName: "sharedKey",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LocalUserRegeneratePasswordResult = {
    type: {
        name: "Composite",
        className: "LocalUserRegeneratePasswordResult",
        modelProperties: {
            sshPassword: {
                serializedName: "sshPassword",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EncryptionScopeKeyVaultProperties = {
    type: {
        name: "Composite",
        className: "EncryptionScopeKeyVaultProperties",
        modelProperties: {
            keyUri: {
                serializedName: "keyUri",
                type: {
                    name: "String"
                }
            },
            currentVersionedKeyIdentifier: {
                serializedName: "currentVersionedKeyIdentifier",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            lastKeyRotationTimestamp: {
                serializedName: "lastKeyRotationTimestamp",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const EncryptionScopeListResult = {
    type: {
        name: "Composite",
        className: "EncryptionScopeListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EncryptionScope"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BlobServiceItems = {
    type: {
        name: "Composite",
        className: "BlobServiceItems",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BlobServiceProperties"
                        }
                    }
                }
            }
        }
    }
};
const CorsRules = {
    type: {
        name: "Composite",
        className: "CorsRules",
        modelProperties: {
            corsRules: {
                serializedName: "corsRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CorsRule"
                        }
                    }
                }
            }
        }
    }
};
const CorsRule = {
    type: {
        name: "Composite",
        className: "CorsRule",
        modelProperties: {
            allowedOrigins: {
                serializedName: "allowedOrigins",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            allowedMethods: {
                serializedName: "allowedMethods",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            maxAgeInSeconds: {
                serializedName: "maxAgeInSeconds",
                required: true,
                type: {
                    name: "Number"
                }
            },
            exposedHeaders: {
                serializedName: "exposedHeaders",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            allowedHeaders: {
                serializedName: "allowedHeaders",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const DeleteRetentionPolicy = {
    type: {
        name: "Composite",
        className: "DeleteRetentionPolicy",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            days: {
                constraints: {
                    InclusiveMaximum: 365,
                    InclusiveMinimum: 1
                },
                serializedName: "days",
                type: {
                    name: "Number"
                }
            },
            allowPermanentDelete: {
                serializedName: "allowPermanentDelete",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ChangeFeed = {
    type: {
        name: "Composite",
        className: "ChangeFeed",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            retentionInDays: {
                constraints: {
                    InclusiveMaximum: 146000,
                    InclusiveMinimum: 1
                },
                serializedName: "retentionInDays",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const RestorePolicyProperties = {
    type: {
        name: "Composite",
        className: "RestorePolicyProperties",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            days: {
                constraints: {
                    InclusiveMaximum: 365,
                    InclusiveMinimum: 1
                },
                serializedName: "days",
                type: {
                    name: "Number"
                }
            },
            lastEnabledTime: {
                serializedName: "lastEnabledTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            minRestoreTime: {
                serializedName: "minRestoreTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const LastAccessTimeTrackingPolicy = {
    type: {
        name: "Composite",
        className: "LastAccessTimeTrackingPolicy",
        modelProperties: {
            enable: {
                serializedName: "enable",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            trackingGranularityInDays: {
                serializedName: "trackingGranularityInDays",
                type: {
                    name: "Number"
                }
            },
            blobType: {
                serializedName: "blobType",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ListContainerItems = {
    type: {
        name: "Composite",
        className: "ListContainerItems",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ListContainerItem"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ImmutabilityPolicyProperties = {
    type: {
        name: "Composite",
        className: "ImmutabilityPolicyProperties",
        modelProperties: {
            etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            updateHistory: {
                serializedName: "updateHistory",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "UpdateHistoryProperty"
                        }
                    }
                }
            },
            immutabilityPeriodSinceCreationInDays: {
                serializedName: "properties.immutabilityPeriodSinceCreationInDays",
                type: {
                    name: "Number"
                }
            },
            state: {
                serializedName: "properties.state",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            allowProtectedAppendWrites: {
                serializedName: "properties.allowProtectedAppendWrites",
                type: {
                    name: "Boolean"
                }
            },
            allowProtectedAppendWritesAll: {
                serializedName: "properties.allowProtectedAppendWritesAll",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const UpdateHistoryProperty = {
    type: {
        name: "Composite",
        className: "UpdateHistoryProperty",
        modelProperties: {
            update: {
                serializedName: "update",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            immutabilityPeriodSinceCreationInDays: {
                serializedName: "immutabilityPeriodSinceCreationInDays",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            timestamp: {
                serializedName: "timestamp",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            objectIdentifier: {
                serializedName: "objectIdentifier",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            upn: {
                serializedName: "upn",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            allowProtectedAppendWrites: {
                serializedName: "allowProtectedAppendWrites",
                type: {
                    name: "Boolean"
                }
            },
            allowProtectedAppendWritesAll: {
                serializedName: "allowProtectedAppendWritesAll",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const LegalHoldProperties = {
    type: {
        name: "Composite",
        className: "LegalHoldProperties",
        modelProperties: {
            hasLegalHold: {
                serializedName: "hasLegalHold",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TagProperty"
                        }
                    }
                }
            },
            protectedAppendWritesHistory: {
                serializedName: "protectedAppendWritesHistory",
                type: {
                    name: "Composite",
                    className: "ProtectedAppendWritesHistory"
                }
            }
        }
    }
};
const TagProperty = {
    type: {
        name: "Composite",
        className: "TagProperty",
        modelProperties: {
            tag: {
                serializedName: "tag",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            timestamp: {
                serializedName: "timestamp",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            objectIdentifier: {
                serializedName: "objectIdentifier",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            upn: {
                serializedName: "upn",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ProtectedAppendWritesHistory = {
    type: {
        name: "Composite",
        className: "ProtectedAppendWritesHistory",
        modelProperties: {
            allowProtectedAppendWritesAll: {
                serializedName: "allowProtectedAppendWritesAll",
                type: {
                    name: "Boolean"
                }
            },
            timestamp: {
                serializedName: "timestamp",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const ImmutableStorageWithVersioning = {
    type: {
        name: "Composite",
        className: "ImmutableStorageWithVersioning",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            timeStamp: {
                serializedName: "timeStamp",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            migrationState: {
                serializedName: "migrationState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LegalHold = {
    type: {
        name: "Composite",
        className: "LegalHold",
        modelProperties: {
            hasLegalHold: {
                serializedName: "hasLegalHold",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            tags: {
                serializedName: "tags",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        constraints: {
                            MaxLength: 23,
                            MinLength: 3
                        },
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            allowProtectedAppendWritesAll: {
                serializedName: "allowProtectedAppendWritesAll",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const LeaseContainerRequest = {
    type: {
        name: "Composite",
        className: "LeaseContainerRequest",
        modelProperties: {
            action: {
                serializedName: "action",
                required: true,
                type: {
                    name: "String"
                }
            },
            leaseId: {
                serializedName: "leaseId",
                type: {
                    name: "String"
                }
            },
            breakPeriod: {
                serializedName: "breakPeriod",
                type: {
                    name: "Number"
                }
            },
            leaseDuration: {
                serializedName: "leaseDuration",
                type: {
                    name: "Number"
                }
            },
            proposedLeaseId: {
                serializedName: "proposedLeaseId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LeaseContainerResponse = {
    type: {
        name: "Composite",
        className: "LeaseContainerResponse",
        modelProperties: {
            leaseId: {
                serializedName: "leaseId",
                type: {
                    name: "String"
                }
            },
            leaseTimeSeconds: {
                serializedName: "leaseTimeSeconds",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FileServiceItems = {
    type: {
        name: "Composite",
        className: "FileServiceItems",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FileServiceProperties"
                        }
                    }
                }
            }
        }
    }
};
const ProtocolSettings = {
    type: {
        name: "Composite",
        className: "ProtocolSettings",
        modelProperties: {
            smb: {
                serializedName: "smb",
                type: {
                    name: "Composite",
                    className: "SmbSetting"
                }
            }
        }
    }
};
const SmbSetting = {
    type: {
        name: "Composite",
        className: "SmbSetting",
        modelProperties: {
            multichannel: {
                serializedName: "multichannel",
                type: {
                    name: "Composite",
                    className: "Multichannel"
                }
            },
            versions: {
                serializedName: "versions",
                type: {
                    name: "String"
                }
            },
            authenticationMethods: {
                serializedName: "authenticationMethods",
                type: {
                    name: "String"
                }
            },
            kerberosTicketEncryption: {
                serializedName: "kerberosTicketEncryption",
                type: {
                    name: "String"
                }
            },
            channelEncryption: {
                serializedName: "channelEncryption",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Multichannel = {
    type: {
        name: "Composite",
        className: "Multichannel",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const FileShareItems = {
    type: {
        name: "Composite",
        className: "FileShareItems",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FileShareItem"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SignedIdentifier = {
    type: {
        name: "Composite",
        className: "SignedIdentifier",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            accessPolicy: {
                serializedName: "accessPolicy",
                type: {
                    name: "Composite",
                    className: "AccessPolicy"
                }
            }
        }
    }
};
const AccessPolicy = {
    type: {
        name: "Composite",
        className: "AccessPolicy",
        modelProperties: {
            startTime: {
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            expiryTime: {
                serializedName: "expiryTime",
                type: {
                    name: "DateTime"
                }
            },
            permission: {
                serializedName: "permission",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeletedShare = {
    type: {
        name: "Composite",
        className: "DeletedShare",
        modelProperties: {
            deletedShareName: {
                serializedName: "deletedShareName",
                required: true,
                type: {
                    name: "String"
                }
            },
            deletedShareVersion: {
                serializedName: "deletedShareVersion",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LeaseShareRequest = {
    type: {
        name: "Composite",
        className: "LeaseShareRequest",
        modelProperties: {
            action: {
                serializedName: "action",
                required: true,
                type: {
                    name: "String"
                }
            },
            leaseId: {
                serializedName: "leaseId",
                type: {
                    name: "String"
                }
            },
            breakPeriod: {
                serializedName: "breakPeriod",
                type: {
                    name: "Number"
                }
            },
            leaseDuration: {
                serializedName: "leaseDuration",
                type: {
                    name: "Number"
                }
            },
            proposedLeaseId: {
                serializedName: "proposedLeaseId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LeaseShareResponse = {
    type: {
        name: "Composite",
        className: "LeaseShareResponse",
        modelProperties: {
            leaseId: {
                serializedName: "leaseId",
                type: {
                    name: "String"
                }
            },
            leaseTimeSeconds: {
                serializedName: "leaseTimeSeconds",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListQueueServices = {
    type: {
        name: "Composite",
        className: "ListQueueServices",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QueueServiceProperties"
                        }
                    }
                }
            }
        }
    }
};
const ListQueueResource = {
    type: {
        name: "Composite",
        className: "ListQueueResource",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ListQueue"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListTableServices = {
    type: {
        name: "Composite",
        className: "ListTableServices",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TableServiceProperties"
                        }
                    }
                }
            }
        }
    }
};
const TableSignedIdentifier = {
    type: {
        name: "Composite",
        className: "TableSignedIdentifier",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            accessPolicy: {
                serializedName: "accessPolicy",
                type: {
                    name: "Composite",
                    className: "TableAccessPolicy"
                }
            }
        }
    }
};
const TableAccessPolicy = {
    type: {
        name: "Composite",
        className: "TableAccessPolicy",
        modelProperties: {
            startTime: {
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            expiryTime: {
                serializedName: "expiryTime",
                type: {
                    name: "DateTime"
                }
            },
            permission: {
                serializedName: "permission",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListTableResource = {
    type: {
        name: "Composite",
        className: "ListTableResource",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Table"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpointConnection = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnection",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { privateEndpoint: {
                serializedName: "properties.privateEndpoint",
                type: {
                    name: "Composite",
                    className: "PrivateEndpoint"
                }
            }, privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkServiceConnectionState"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const TrackedResource = {
    type: {
        name: "Composite",
        className: "TrackedResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ProxyResource = {
    type: {
        name: "Composite",
        className: "ProxyResource",
        modelProperties: Object.assign({}, Resource.type.modelProperties)
    }
};
const ManagementPolicy = {
    type: {
        name: "Composite",
        className: "ManagementPolicy",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { lastModifiedTime: {
                serializedName: "properties.lastModifiedTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, policy: {
                serializedName: "properties.policy",
                type: {
                    name: "Composite",
                    className: "ManagementPolicySchema"
                }
            } })
    }
};
const BlobInventoryPolicy = {
    type: {
        name: "Composite",
        className: "BlobInventoryPolicy",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, lastModifiedTime: {
                serializedName: "properties.lastModifiedTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, policy: {
                serializedName: "properties.policy",
                type: {
                    name: "Composite",
                    className: "BlobInventoryPolicySchema"
                }
            } })
    }
};
const PrivateLinkResource = {
    type: {
        name: "Composite",
        className: "PrivateLinkResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { groupId: {
                serializedName: "properties.groupId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, requiredMembers: {
                serializedName: "properties.requiredMembers",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, requiredZoneNames: {
                serializedName: "properties.requiredZoneNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const ObjectReplicationPolicy = {
    type: {
        name: "Composite",
        className: "ObjectReplicationPolicy",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { policyId: {
                serializedName: "properties.policyId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, enabledTime: {
                serializedName: "properties.enabledTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, sourceAccount: {
                serializedName: "properties.sourceAccount",
                type: {
                    name: "String"
                }
            }, destinationAccount: {
                serializedName: "properties.destinationAccount",
                type: {
                    name: "String"
                }
            }, rules: {
                serializedName: "properties.rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ObjectReplicationPolicyRule"
                        }
                    }
                }
            } })
    }
};
const LocalUser = {
    type: {
        name: "Composite",
        className: "LocalUser",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, permissionScopes: {
                serializedName: "properties.permissionScopes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PermissionScope"
                        }
                    }
                }
            }, homeDirectory: {
                serializedName: "properties.homeDirectory",
                type: {
                    name: "String"
                }
            }, sshAuthorizedKeys: {
                serializedName: "properties.sshAuthorizedKeys",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SshPublicKey"
                        }
                    }
                }
            }, sid: {
                serializedName: "properties.sid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, hasSharedKey: {
                serializedName: "properties.hasSharedKey",
                type: {
                    name: "Boolean"
                }
            }, hasSshKey: {
                serializedName: "properties.hasSshKey",
                type: {
                    name: "Boolean"
                }
            }, hasSshPassword: {
                serializedName: "properties.hasSshPassword",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const EncryptionScope = {
    type: {
        name: "Composite",
        className: "EncryptionScope",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { source: {
                serializedName: "properties.source",
                type: {
                    name: "String"
                }
            }, state: {
                serializedName: "properties.state",
                type: {
                    name: "String"
                }
            }, creationTime: {
                serializedName: "properties.creationTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, lastModifiedTime: {
                serializedName: "properties.lastModifiedTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, keyVaultProperties: {
                serializedName: "properties.keyVaultProperties",
                type: {
                    name: "Composite",
                    className: "EncryptionScopeKeyVaultProperties"
                }
            }, requireInfrastructureEncryption: {
                serializedName: "properties.requireInfrastructureEncryption",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const BlobServiceProperties = {
    type: {
        name: "Composite",
        className: "BlobServiceProperties",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, cors: {
                serializedName: "properties.cors",
                type: {
                    name: "Composite",
                    className: "CorsRules"
                }
            }, defaultServiceVersion: {
                serializedName: "properties.defaultServiceVersion",
                type: {
                    name: "String"
                }
            }, deleteRetentionPolicy: {
                serializedName: "properties.deleteRetentionPolicy",
                type: {
                    name: "Composite",
                    className: "DeleteRetentionPolicy"
                }
            }, isVersioningEnabled: {
                serializedName: "properties.isVersioningEnabled",
                type: {
                    name: "Boolean"
                }
            }, automaticSnapshotPolicyEnabled: {
                serializedName: "properties.automaticSnapshotPolicyEnabled",
                type: {
                    name: "Boolean"
                }
            }, changeFeed: {
                serializedName: "properties.changeFeed",
                type: {
                    name: "Composite",
                    className: "ChangeFeed"
                }
            }, restorePolicy: {
                serializedName: "properties.restorePolicy",
                type: {
                    name: "Composite",
                    className: "RestorePolicyProperties"
                }
            }, containerDeleteRetentionPolicy: {
                serializedName: "properties.containerDeleteRetentionPolicy",
                type: {
                    name: "Composite",
                    className: "DeleteRetentionPolicy"
                }
            }, lastAccessTimeTrackingPolicy: {
                serializedName: "properties.lastAccessTimeTrackingPolicy",
                type: {
                    name: "Composite",
                    className: "LastAccessTimeTrackingPolicy"
                }
            } })
    }
};
const AzureEntityResource = {
    type: {
        name: "Composite",
        className: "AzureEntityResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const FileServiceProperties = {
    type: {
        name: "Composite",
        className: "FileServiceProperties",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, cors: {
                serializedName: "properties.cors",
                type: {
                    name: "Composite",
                    className: "CorsRules"
                }
            }, shareDeleteRetentionPolicy: {
                serializedName: "properties.shareDeleteRetentionPolicy",
                type: {
                    name: "Composite",
                    className: "DeleteRetentionPolicy"
                }
            }, protocolSettings: {
                serializedName: "properties.protocolSettings",
                type: {
                    name: "Composite",
                    className: "ProtocolSettings"
                }
            } })
    }
};
const QueueServiceProperties = {
    type: {
        name: "Composite",
        className: "QueueServiceProperties",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { cors: {
                serializedName: "properties.cors",
                type: {
                    name: "Composite",
                    className: "CorsRules"
                }
            } })
    }
};
const StorageQueue = {
    type: {
        name: "Composite",
        className: "StorageQueue",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { metadata: {
                serializedName: "properties.metadata",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, approximateMessageCount: {
                serializedName: "properties.approximateMessageCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const ListQueue = {
    type: {
        name: "Composite",
        className: "ListQueue",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { metadata: {
                serializedName: "properties.metadata",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            } })
    }
};
const TableServiceProperties = {
    type: {
        name: "Composite",
        className: "TableServiceProperties",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { cors: {
                serializedName: "properties.cors",
                type: {
                    name: "Composite",
                    className: "CorsRules"
                }
            } })
    }
};
const Table = {
    type: {
        name: "Composite",
        className: "Table",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { tableName: {
                serializedName: "properties.tableName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, signedIdentifiers: {
                serializedName: "properties.signedIdentifiers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TableSignedIdentifier"
                        }
                    }
                }
            } })
    }
};
const StorageAccount = {
    type: {
        name: "Composite",
        className: "StorageAccount",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, kind: {
                serializedName: "kind",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "Identity"
                }
            }, extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Creating", "ResolvingDNS", "Succeeded"]
                }
            }, primaryEndpoints: {
                serializedName: "properties.primaryEndpoints",
                type: {
                    name: "Composite",
                    className: "Endpoints"
                }
            }, primaryLocation: {
                serializedName: "properties.primaryLocation",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, statusOfPrimary: {
                serializedName: "properties.statusOfPrimary",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["available", "unavailable"]
                }
            }, lastGeoFailoverTime: {
                serializedName: "properties.lastGeoFailoverTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, secondaryLocation: {
                serializedName: "properties.secondaryLocation",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, statusOfSecondary: {
                serializedName: "properties.statusOfSecondary",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["available", "unavailable"]
                }
            }, creationTime: {
                serializedName: "properties.creationTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, customDomain: {
                serializedName: "properties.customDomain",
                type: {
                    name: "Composite",
                    className: "CustomDomain"
                }
            }, sasPolicy: {
                serializedName: "properties.sasPolicy",
                type: {
                    name: "Composite",
                    className: "SasPolicy"
                }
            }, keyPolicy: {
                serializedName: "properties.keyPolicy",
                type: {
                    name: "Composite",
                    className: "KeyPolicy"
                }
            }, keyCreationTime: {
                serializedName: "properties.keyCreationTime",
                type: {
                    name: "Composite",
                    className: "KeyCreationTime"
                }
            }, secondaryEndpoints: {
                serializedName: "properties.secondaryEndpoints",
                type: {
                    name: "Composite",
                    className: "Endpoints"
                }
            }, encryption: {
                serializedName: "properties.encryption",
                type: {
                    name: "Composite",
                    className: "Encryption"
                }
            }, accessTier: {
                serializedName: "properties.accessTier",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Hot", "Cool", "Premium"]
                }
            }, azureFilesIdentityBasedAuthentication: {
                serializedName: "properties.azureFilesIdentityBasedAuthentication",
                type: {
                    name: "Composite",
                    className: "AzureFilesIdentityBasedAuthentication"
                }
            }, enableHttpsTrafficOnly: {
                serializedName: "properties.supportsHttpsTrafficOnly",
                type: {
                    name: "Boolean"
                }
            }, networkRuleSet: {
                serializedName: "properties.networkAcls",
                type: {
                    name: "Composite",
                    className: "NetworkRuleSet"
                }
            }, isSftpEnabled: {
                serializedName: "properties.isSftpEnabled",
                type: {
                    name: "Boolean"
                }
            }, isLocalUserEnabled: {
                serializedName: "properties.isLocalUserEnabled",
                type: {
                    name: "Boolean"
                }
            }, isHnsEnabled: {
                serializedName: "properties.isHnsEnabled",
                type: {
                    name: "Boolean"
                }
            }, geoReplicationStats: {
                serializedName: "properties.geoReplicationStats",
                type: {
                    name: "Composite",
                    className: "GeoReplicationStats"
                }
            }, failoverInProgress: {
                serializedName: "properties.failoverInProgress",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, largeFileSharesState: {
                serializedName: "properties.largeFileSharesState",
                type: {
                    name: "String"
                }
            }, privateEndpointConnections: {
                serializedName: "properties.privateEndpointConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            }, routingPreference: {
                serializedName: "properties.routingPreference",
                type: {
                    name: "Composite",
                    className: "RoutingPreference"
                }
            }, blobRestoreStatus: {
                serializedName: "properties.blobRestoreStatus",
                type: {
                    name: "Composite",
                    className: "BlobRestoreStatus"
                }
            }, allowBlobPublicAccess: {
                serializedName: "properties.allowBlobPublicAccess",
                type: {
                    name: "Boolean"
                }
            }, minimumTlsVersion: {
                serializedName: "properties.minimumTlsVersion",
                type: {
                    name: "String"
                }
            }, allowSharedKeyAccess: {
                serializedName: "properties.allowSharedKeyAccess",
                type: {
                    name: "Boolean"
                }
            }, enableNfsV3: {
                serializedName: "properties.isNfsV3Enabled",
                type: {
                    name: "Boolean"
                }
            }, allowCrossTenantReplication: {
                serializedName: "properties.allowCrossTenantReplication",
                type: {
                    name: "Boolean"
                }
            }, defaultToOAuthAuthentication: {
                serializedName: "properties.defaultToOAuthAuthentication",
                type: {
                    name: "Boolean"
                }
            }, publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            }, immutableStorageWithVersioning: {
                serializedName: "properties.immutableStorageWithVersioning",
                type: {
                    name: "Composite",
                    className: "ImmutableStorageAccount"
                }
            }, allowedCopyScope: {
                serializedName: "properties.allowedCopyScope",
                type: {
                    name: "String"
                }
            }, storageAccountSkuConversionStatus: {
                serializedName: "properties.storageAccountSkuConversionStatus",
                type: {
                    name: "Composite",
                    className: "StorageAccountSkuConversionStatus"
                }
            }, dnsEndpointType: {
                serializedName: "properties.dnsEndpointType",
                type: {
                    name: "String"
                }
            }, isSkuConversionBlocked: {
                serializedName: "properties.isSkuConversionBlocked",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, accountMigrationInProgress: {
                serializedName: "properties.accountMigrationInProgress",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const DeletedAccount = {
    type: {
        name: "Composite",
        className: "DeletedAccount",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { storageAccountResourceId: {
                serializedName: "properties.storageAccountResourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, location: {
                serializedName: "properties.location",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, restoreReference: {
                serializedName: "properties.restoreReference",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, creationTime: {
                serializedName: "properties.creationTime",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, deletionTime: {
                serializedName: "properties.deletionTime",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ListContainerItem = {
    type: {
        name: "Composite",
        className: "ListContainerItem",
        modelProperties: Object.assign(Object.assign({}, AzureEntityResource.type.modelProperties), { version: {
                serializedName: "properties.version",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, deleted: {
                serializedName: "properties.deleted",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, deletedTime: {
                serializedName: "properties.deletedTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, remainingRetentionDays: {
                serializedName: "properties.remainingRetentionDays",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, defaultEncryptionScope: {
                serializedName: "properties.defaultEncryptionScope",
                type: {
                    name: "String"
                }
            }, denyEncryptionScopeOverride: {
                serializedName: "properties.denyEncryptionScopeOverride",
                type: {
                    name: "Boolean"
                }
            }, publicAccess: {
                serializedName: "properties.publicAccess",
                type: {
                    name: "Enum",
                    allowedValues: ["Container", "Blob", "None"]
                }
            }, lastModifiedTime: {
                serializedName: "properties.lastModifiedTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, leaseStatus: {
                serializedName: "properties.leaseStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, leaseState: {
                serializedName: "properties.leaseState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, leaseDuration: {
                serializedName: "properties.leaseDuration",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, metadata: {
                serializedName: "properties.metadata",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, immutabilityPolicy: {
                serializedName: "properties.immutabilityPolicy",
                type: {
                    name: "Composite",
                    className: "ImmutabilityPolicyProperties"
                }
            }, legalHold: {
                serializedName: "properties.legalHold",
                type: {
                    name: "Composite",
                    className: "LegalHoldProperties"
                }
            }, hasLegalHold: {
                serializedName: "properties.hasLegalHold",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, hasImmutabilityPolicy: {
                serializedName: "properties.hasImmutabilityPolicy",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, immutableStorageWithVersioning: {
                serializedName: "properties.immutableStorageWithVersioning",
                type: {
                    name: "Composite",
                    className: "ImmutableStorageWithVersioning"
                }
            }, enableNfsV3RootSquash: {
                serializedName: "properties.enableNfsV3RootSquash",
                type: {
                    name: "Boolean"
                }
            }, enableNfsV3AllSquash: {
                serializedName: "properties.enableNfsV3AllSquash",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const BlobContainer = {
    type: {
        name: "Composite",
        className: "BlobContainer",
        modelProperties: Object.assign(Object.assign({}, AzureEntityResource.type.modelProperties), { version: {
                serializedName: "properties.version",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, deleted: {
                serializedName: "properties.deleted",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, deletedTime: {
                serializedName: "properties.deletedTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, remainingRetentionDays: {
                serializedName: "properties.remainingRetentionDays",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, defaultEncryptionScope: {
                serializedName: "properties.defaultEncryptionScope",
                type: {
                    name: "String"
                }
            }, denyEncryptionScopeOverride: {
                serializedName: "properties.denyEncryptionScopeOverride",
                type: {
                    name: "Boolean"
                }
            }, publicAccess: {
                serializedName: "properties.publicAccess",
                type: {
                    name: "Enum",
                    allowedValues: ["Container", "Blob", "None"]
                }
            }, lastModifiedTime: {
                serializedName: "properties.lastModifiedTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, leaseStatus: {
                serializedName: "properties.leaseStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, leaseState: {
                serializedName: "properties.leaseState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, leaseDuration: {
                serializedName: "properties.leaseDuration",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, metadata: {
                serializedName: "properties.metadata",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, immutabilityPolicy: {
                serializedName: "properties.immutabilityPolicy",
                type: {
                    name: "Composite",
                    className: "ImmutabilityPolicyProperties"
                }
            }, legalHold: {
                serializedName: "properties.legalHold",
                type: {
                    name: "Composite",
                    className: "LegalHoldProperties"
                }
            }, hasLegalHold: {
                serializedName: "properties.hasLegalHold",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, hasImmutabilityPolicy: {
                serializedName: "properties.hasImmutabilityPolicy",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, immutableStorageWithVersioning: {
                serializedName: "properties.immutableStorageWithVersioning",
                type: {
                    name: "Composite",
                    className: "ImmutableStorageWithVersioning"
                }
            }, enableNfsV3RootSquash: {
                serializedName: "properties.enableNfsV3RootSquash",
                type: {
                    name: "Boolean"
                }
            }, enableNfsV3AllSquash: {
                serializedName: "properties.enableNfsV3AllSquash",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const ImmutabilityPolicy = {
    type: {
        name: "Composite",
        className: "ImmutabilityPolicy",
        modelProperties: Object.assign(Object.assign({}, AzureEntityResource.type.modelProperties), { immutabilityPeriodSinceCreationInDays: {
                serializedName: "properties.immutabilityPeriodSinceCreationInDays",
                type: {
                    name: "Number"
                }
            }, state: {
                serializedName: "properties.state",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, allowProtectedAppendWrites: {
                serializedName: "properties.allowProtectedAppendWrites",
                type: {
                    name: "Boolean"
                }
            }, allowProtectedAppendWritesAll: {
                serializedName: "properties.allowProtectedAppendWritesAll",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const FileShareItem = {
    type: {
        name: "Composite",
        className: "FileShareItem",
        modelProperties: Object.assign(Object.assign({}, AzureEntityResource.type.modelProperties), { lastModifiedTime: {
                serializedName: "properties.lastModifiedTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, metadata: {
                serializedName: "properties.metadata",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, shareQuota: {
                constraints: {
                    InclusiveMaximum: 102400,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.shareQuota",
                type: {
                    name: "Number"
                }
            }, enabledProtocols: {
                serializedName: "properties.enabledProtocols",
                type: {
                    name: "String"
                }
            }, rootSquash: {
                serializedName: "properties.rootSquash",
                type: {
                    name: "String"
                }
            }, version: {
                serializedName: "properties.version",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, deleted: {
                serializedName: "properties.deleted",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, deletedTime: {
                serializedName: "properties.deletedTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, remainingRetentionDays: {
                serializedName: "properties.remainingRetentionDays",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, accessTier: {
                serializedName: "properties.accessTier",
                type: {
                    name: "String"
                }
            }, accessTierChangeTime: {
                serializedName: "properties.accessTierChangeTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, accessTierStatus: {
                serializedName: "properties.accessTierStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, shareUsageBytes: {
                serializedName: "properties.shareUsageBytes",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, leaseStatus: {
                serializedName: "properties.leaseStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, leaseState: {
                serializedName: "properties.leaseState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, leaseDuration: {
                serializedName: "properties.leaseDuration",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, signedIdentifiers: {
                serializedName: "properties.signedIdentifiers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SignedIdentifier"
                        }
                    }
                }
            }, snapshotTime: {
                serializedName: "properties.snapshotTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const FileShare = {
    type: {
        name: "Composite",
        className: "FileShare",
        modelProperties: Object.assign(Object.assign({}, AzureEntityResource.type.modelProperties), { lastModifiedTime: {
                serializedName: "properties.lastModifiedTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, metadata: {
                serializedName: "properties.metadata",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, shareQuota: {
                constraints: {
                    InclusiveMaximum: 102400,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.shareQuota",
                type: {
                    name: "Number"
                }
            }, enabledProtocols: {
                serializedName: "properties.enabledProtocols",
                type: {
                    name: "String"
                }
            }, rootSquash: {
                serializedName: "properties.rootSquash",
                type: {
                    name: "String"
                }
            }, version: {
                serializedName: "properties.version",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, deleted: {
                serializedName: "properties.deleted",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, deletedTime: {
                serializedName: "properties.deletedTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, remainingRetentionDays: {
                serializedName: "properties.remainingRetentionDays",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, accessTier: {
                serializedName: "properties.accessTier",
                type: {
                    name: "String"
                }
            }, accessTierChangeTime: {
                serializedName: "properties.accessTierChangeTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, accessTierStatus: {
                serializedName: "properties.accessTierStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, shareUsageBytes: {
                serializedName: "properties.shareUsageBytes",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, leaseStatus: {
                serializedName: "properties.leaseStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, leaseState: {
                serializedName: "properties.leaseState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, leaseDuration: {
                serializedName: "properties.leaseDuration",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, signedIdentifiers: {
                serializedName: "properties.signedIdentifiers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SignedIdentifier"
                        }
                    }
                }
            }, snapshotTime: {
                serializedName: "properties.snapshotTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const StorageAccountsCustomerInitiatedMigrationHeaders = {
    type: {
        name: "Composite",
        className: "StorageAccountsCustomerInitiatedMigrationHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BlobContainersCreateOrUpdateImmutabilityPolicyHeaders = {
    type: {
        name: "Composite",
        className: "BlobContainersCreateOrUpdateImmutabilityPolicyHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BlobContainersGetImmutabilityPolicyHeaders = {
    type: {
        name: "Composite",
        className: "BlobContainersGetImmutabilityPolicyHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BlobContainersDeleteImmutabilityPolicyHeaders = {
    type: {
        name: "Composite",
        className: "BlobContainersDeleteImmutabilityPolicyHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BlobContainersLockImmutabilityPolicyHeaders = {
    type: {
        name: "Composite",
        className: "BlobContainersLockImmutabilityPolicyHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BlobContainersExtendImmutabilityPolicyHeaders = {
    type: {
        name: "Composite",
        className: "BlobContainersExtendImmutabilityPolicyHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FileSharesLeaseHeaders = {
    type: {
        name: "Composite",
        className: "FileSharesLeaseHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    OperationListResult: OperationListResult,
    Operation: Operation,
    OperationDisplay: OperationDisplay,
    ServiceSpecification: ServiceSpecification,
    MetricSpecification: MetricSpecification,
    Dimension: Dimension,
    StorageSkuListResult: StorageSkuListResult,
    SkuInformation: SkuInformation,
    SKUCapability: SKUCapability,
    Restriction: Restriction,
    StorageAccountCheckNameAvailabilityParameters: StorageAccountCheckNameAvailabilityParameters,
    CheckNameAvailabilityResult: CheckNameAvailabilityResult,
    StorageAccountCreateParameters: StorageAccountCreateParameters,
    Sku: Sku,
    ExtendedLocation: ExtendedLocation,
    Identity: Identity,
    UserAssignedIdentity: UserAssignedIdentity,
    SasPolicy: SasPolicy,
    KeyPolicy: KeyPolicy,
    CustomDomain: CustomDomain,
    Encryption: Encryption,
    EncryptionServices: EncryptionServices,
    EncryptionService: EncryptionService,
    KeyVaultProperties: KeyVaultProperties,
    EncryptionIdentity: EncryptionIdentity,
    NetworkRuleSet: NetworkRuleSet,
    ResourceAccessRule: ResourceAccessRule,
    VirtualNetworkRule: VirtualNetworkRule,
    IPRule: IPRule,
    AzureFilesIdentityBasedAuthentication: AzureFilesIdentityBasedAuthentication,
    ActiveDirectoryProperties: ActiveDirectoryProperties,
    RoutingPreference: RoutingPreference,
    ImmutableStorageAccount: ImmutableStorageAccount,
    AccountImmutabilityPolicyProperties: AccountImmutabilityPolicyProperties,
    Endpoints: Endpoints,
    StorageAccountMicrosoftEndpoints: StorageAccountMicrosoftEndpoints,
    StorageAccountInternetEndpoints: StorageAccountInternetEndpoints,
    KeyCreationTime: KeyCreationTime,
    GeoReplicationStats: GeoReplicationStats,
    PrivateEndpoint: PrivateEndpoint,
    PrivateLinkServiceConnectionState: PrivateLinkServiceConnectionState,
    Resource: Resource,
    BlobRestoreStatus: BlobRestoreStatus,
    BlobRestoreParameters: BlobRestoreParameters,
    BlobRestoreRange: BlobRestoreRange,
    StorageAccountSkuConversionStatus: StorageAccountSkuConversionStatus,
    StorageAccountUpdateParameters: StorageAccountUpdateParameters,
    DeletedAccountListResult: DeletedAccountListResult,
    ErrorResponse: ErrorResponse,
    ErrorResponseBody: ErrorResponseBody,
    StorageAccountListResult: StorageAccountListResult,
    StorageAccountListKeysResult: StorageAccountListKeysResult,
    StorageAccountKey: StorageAccountKey,
    StorageAccountRegenerateKeyParameters: StorageAccountRegenerateKeyParameters,
    UsageListResult: UsageListResult,
    Usage: Usage,
    UsageName: UsageName,
    AccountSasParameters: AccountSasParameters,
    ListAccountSasResponse: ListAccountSasResponse,
    ServiceSasParameters: ServiceSasParameters,
    ListServiceSasResponse: ListServiceSasResponse,
    StorageAccountMigration: StorageAccountMigration,
    ErrorResponseAutoGenerated: ErrorResponseAutoGenerated,
    ErrorDetail: ErrorDetail,
    ErrorAdditionalInfo: ErrorAdditionalInfo,
    ManagementPolicySchema: ManagementPolicySchema,
    ManagementPolicyRule: ManagementPolicyRule,
    ManagementPolicyDefinition: ManagementPolicyDefinition,
    ManagementPolicyAction: ManagementPolicyAction,
    ManagementPolicyBaseBlob: ManagementPolicyBaseBlob,
    DateAfterModification: DateAfterModification,
    ManagementPolicySnapShot: ManagementPolicySnapShot,
    DateAfterCreation: DateAfterCreation,
    ManagementPolicyVersion: ManagementPolicyVersion,
    ManagementPolicyFilter: ManagementPolicyFilter,
    TagFilter: TagFilter,
    BlobInventoryPolicySchema: BlobInventoryPolicySchema,
    BlobInventoryPolicyRule: BlobInventoryPolicyRule,
    BlobInventoryPolicyDefinition: BlobInventoryPolicyDefinition,
    BlobInventoryPolicyFilter: BlobInventoryPolicyFilter,
    BlobInventoryCreationTime: BlobInventoryCreationTime,
    SystemData: SystemData,
    CloudError: CloudError,
    CloudErrorBody: CloudErrorBody,
    ListBlobInventoryPolicy: ListBlobInventoryPolicy,
    PrivateEndpointConnectionListResult: PrivateEndpointConnectionListResult,
    PrivateLinkResourceListResult: PrivateLinkResourceListResult,
    ObjectReplicationPolicies: ObjectReplicationPolicies,
    ObjectReplicationPolicyRule: ObjectReplicationPolicyRule,
    ObjectReplicationPolicyFilter: ObjectReplicationPolicyFilter,
    LocalUsers: LocalUsers,
    PermissionScope: PermissionScope,
    SshPublicKey: SshPublicKey,
    LocalUserKeys: LocalUserKeys,
    LocalUserRegeneratePasswordResult: LocalUserRegeneratePasswordResult,
    EncryptionScopeKeyVaultProperties: EncryptionScopeKeyVaultProperties,
    EncryptionScopeListResult: EncryptionScopeListResult,
    BlobServiceItems: BlobServiceItems,
    CorsRules: CorsRules,
    CorsRule: CorsRule,
    DeleteRetentionPolicy: DeleteRetentionPolicy,
    ChangeFeed: ChangeFeed,
    RestorePolicyProperties: RestorePolicyProperties,
    LastAccessTimeTrackingPolicy: LastAccessTimeTrackingPolicy,
    ListContainerItems: ListContainerItems,
    ImmutabilityPolicyProperties: ImmutabilityPolicyProperties,
    UpdateHistoryProperty: UpdateHistoryProperty,
    LegalHoldProperties: LegalHoldProperties,
    TagProperty: TagProperty,
    ProtectedAppendWritesHistory: ProtectedAppendWritesHistory,
    ImmutableStorageWithVersioning: ImmutableStorageWithVersioning,
    LegalHold: LegalHold,
    LeaseContainerRequest: LeaseContainerRequest,
    LeaseContainerResponse: LeaseContainerResponse,
    FileServiceItems: FileServiceItems,
    ProtocolSettings: ProtocolSettings,
    SmbSetting: SmbSetting,
    Multichannel: Multichannel,
    FileShareItems: FileShareItems,
    SignedIdentifier: SignedIdentifier,
    AccessPolicy: AccessPolicy,
    DeletedShare: DeletedShare,
    LeaseShareRequest: LeaseShareRequest,
    LeaseShareResponse: LeaseShareResponse,
    ListQueueServices: ListQueueServices,
    ListQueueResource: ListQueueResource,
    ListTableServices: ListTableServices,
    TableSignedIdentifier: TableSignedIdentifier,
    TableAccessPolicy: TableAccessPolicy,
    ListTableResource: ListTableResource,
    PrivateEndpointConnection: PrivateEndpointConnection,
    TrackedResource: TrackedResource,
    ProxyResource: ProxyResource,
    ManagementPolicy: ManagementPolicy,
    BlobInventoryPolicy: BlobInventoryPolicy,
    PrivateLinkResource: PrivateLinkResource,
    ObjectReplicationPolicy: ObjectReplicationPolicy,
    LocalUser: LocalUser,
    EncryptionScope: EncryptionScope,
    BlobServiceProperties: BlobServiceProperties,
    AzureEntityResource: AzureEntityResource,
    FileServiceProperties: FileServiceProperties,
    QueueServiceProperties: QueueServiceProperties,
    StorageQueue: StorageQueue,
    ListQueue: ListQueue,
    TableServiceProperties: TableServiceProperties,
    Table: Table,
    StorageAccount: StorageAccount,
    DeletedAccount: DeletedAccount,
    ListContainerItem: ListContainerItem,
    BlobContainer: BlobContainer,
    ImmutabilityPolicy: ImmutabilityPolicy,
    FileShareItem: FileShareItem,
    FileShare: FileShare,
    StorageAccountsCustomerInitiatedMigrationHeaders: StorageAccountsCustomerInitiatedMigrationHeaders,
    BlobContainersCreateOrUpdateImmutabilityPolicyHeaders: BlobContainersCreateOrUpdateImmutabilityPolicyHeaders,
    BlobContainersGetImmutabilityPolicyHeaders: BlobContainersGetImmutabilityPolicyHeaders,
    BlobContainersDeleteImmutabilityPolicyHeaders: BlobContainersDeleteImmutabilityPolicyHeaders,
    BlobContainersLockImmutabilityPolicyHeaders: BlobContainersLockImmutabilityPolicyHeaders,
    BlobContainersExtendImmutabilityPolicyHeaders: BlobContainersExtendImmutabilityPolicyHeaders,
    FileSharesLeaseHeaders: FileSharesLeaseHeaders
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2023-01-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        constraints: {
            MinLength: 1
        },
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const accountName = {
    parameterPath: "accountName",
    mapper: StorageAccountCheckNameAvailabilityParameters
};
const parameters = {
    parameterPath: "parameters",
    mapper: StorageAccountCreateParameters
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        constraints: {
            MaxLength: 90,
            MinLength: 1
        },
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const accountName1 = {
    parameterPath: "accountName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-z0-9]+$"),
            MaxLength: 24,
            MinLength: 3
        },
        serializedName: "accountName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const expand = {
    parameterPath: ["options", "expand"],
    mapper: {
        serializedName: "$expand",
        type: {
            name: "Enum",
            allowedValues: ["geoReplicationStats", "blobRestoreStatus"]
        }
    }
};
const parameters1 = {
    parameterPath: "parameters",
    mapper: StorageAccountUpdateParameters
};
const expand1 = {
    parameterPath: ["options", "expand"],
    mapper: {
        defaultValue: "kerb",
        isConstant: true,
        serializedName: "$expand",
        type: {
            name: "String"
        }
    }
};
const regenerateKey = {
    parameterPath: "regenerateKey",
    mapper: StorageAccountRegenerateKeyParameters
};
const parameters2 = {
    parameterPath: "parameters",
    mapper: AccountSasParameters
};
const parameters3 = {
    parameterPath: "parameters",
    mapper: ServiceSasParameters
};
const failoverType = {
    parameterPath: ["options", "failoverType"],
    mapper: {
        defaultValue: "Planned",
        isConstant: true,
        serializedName: "failoverType",
        type: {
            name: "String"
        }
    }
};
const requestType = {
    parameterPath: "requestType",
    mapper: {
        serializedName: "requestType",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters4 = {
    parameterPath: "parameters",
    mapper: StorageAccountMigration
};
const migrationName = {
    parameterPath: "migrationName",
    mapper: {
        serializedName: "migrationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters5 = {
    parameterPath: "parameters",
    mapper: BlobRestoreParameters
};
const accountName2 = {
    parameterPath: "accountName",
    mapper: {
        constraints: {
            MaxLength: 24,
            MinLength: 3
        },
        serializedName: "accountName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const deletedAccountName = {
    parameterPath: "deletedAccountName",
    mapper: {
        constraints: {
            MaxLength: 24,
            MinLength: 3
        },
        serializedName: "deletedAccountName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const location = {
    parameterPath: "location",
    mapper: {
        serializedName: "location",
        required: true,
        type: {
            name: "String"
        }
    }
};
const managementPolicyName = {
    parameterPath: "managementPolicyName",
    mapper: {
        serializedName: "managementPolicyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const properties = {
    parameterPath: "properties",
    mapper: ManagementPolicy
};
const blobInventoryPolicyName = {
    parameterPath: "blobInventoryPolicyName",
    mapper: {
        serializedName: "blobInventoryPolicyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const properties1 = {
    parameterPath: "properties",
    mapper: BlobInventoryPolicy
};
const privateEndpointConnectionName = {
    parameterPath: "privateEndpointConnectionName",
    mapper: {
        serializedName: "privateEndpointConnectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const properties2 = {
    parameterPath: "properties",
    mapper: PrivateEndpointConnection
};
const objectReplicationPolicyId = {
    parameterPath: "objectReplicationPolicyId",
    mapper: {
        constraints: {
            MinLength: 1
        },
        serializedName: "objectReplicationPolicyId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const properties3 = {
    parameterPath: "properties",
    mapper: ObjectReplicationPolicy
};
const username = {
    parameterPath: "username",
    mapper: {
        constraints: {
            MaxLength: 64,
            MinLength: 3
        },
        serializedName: "username",
        required: true,
        type: {
            name: "String"
        }
    }
};
const properties4 = {
    parameterPath: "properties",
    mapper: LocalUser
};
const encryptionScope = {
    parameterPath: "encryptionScope",
    mapper: EncryptionScope
};
const encryptionScopeName = {
    parameterPath: "encryptionScopeName",
    mapper: {
        constraints: {
            MaxLength: 63,
            MinLength: 3
        },
        serializedName: "encryptionScopeName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const maxpagesize = {
    parameterPath: ["options", "maxpagesize"],
    mapper: {
        constraints: {
            InclusiveMaximum: 5000,
            InclusiveMinimum: 1
        },
        serializedName: "$maxpagesize",
        type: {
            name: "Number"
        }
    }
};
const filter = {
    parameterPath: ["options", "filter"],
    mapper: {
        serializedName: "$filter",
        type: {
            name: "String"
        }
    }
};
const include = {
    parameterPath: ["options", "include"],
    mapper: {
        serializedName: "$include",
        type: {
            name: "String"
        }
    }
};
const parameters6 = {
    parameterPath: "parameters",
    mapper: BlobServiceProperties
};
const blobServicesName = {
    parameterPath: "blobServicesName",
    mapper: {
        defaultValue: "default",
        isConstant: true,
        serializedName: "BlobServicesName",
        type: {
            name: "String"
        }
    }
};
const maxpagesize1 = {
    parameterPath: ["options", "maxpagesize"],
    mapper: {
        serializedName: "$maxpagesize",
        type: {
            name: "String"
        }
    }
};
const include1 = {
    parameterPath: ["options", "include"],
    mapper: {
        serializedName: "$include",
        type: {
            name: "String"
        }
    }
};
const blobContainer = {
    parameterPath: "blobContainer",
    mapper: BlobContainer
};
const containerName = {
    parameterPath: "containerName",
    mapper: {
        constraints: {
            MaxLength: 63,
            MinLength: 3
        },
        serializedName: "containerName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const legalHold = {
    parameterPath: "legalHold",
    mapper: LegalHold
};
const parameters7 = {
    parameterPath: ["options", "parameters"],
    mapper: ImmutabilityPolicy
};
const immutabilityPolicyName = {
    parameterPath: "immutabilityPolicyName",
    mapper: {
        defaultValue: "default",
        isConstant: true,
        serializedName: "immutabilityPolicyName",
        type: {
            name: "String"
        }
    }
};
const ifMatch = {
    parameterPath: ["options", "ifMatch"],
    mapper: {
        serializedName: "If-Match",
        type: {
            name: "String"
        }
    }
};
const ifMatch1 = {
    parameterPath: "ifMatch",
    mapper: {
        serializedName: "If-Match",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters8 = {
    parameterPath: ["options", "parameters"],
    mapper: LeaseContainerRequest
};
const parameters9 = {
    parameterPath: "parameters",
    mapper: FileServiceProperties
};
const fileServicesName = {
    parameterPath: "fileServicesName",
    mapper: {
        defaultValue: "default",
        isConstant: true,
        serializedName: "FileServicesName",
        type: {
            name: "String"
        }
    }
};
const expand2 = {
    parameterPath: ["options", "expand"],
    mapper: {
        serializedName: "$expand",
        type: {
            name: "String"
        }
    }
};
const fileShare = {
    parameterPath: "fileShare",
    mapper: FileShare
};
const shareName = {
    parameterPath: "shareName",
    mapper: {
        constraints: {
            MaxLength: 63,
            MinLength: 3
        },
        serializedName: "shareName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const xMsSnapshot = {
    parameterPath: ["options", "xMsSnapshot"],
    mapper: {
        serializedName: "x-ms-snapshot",
        type: {
            name: "String"
        }
    }
};
const include2 = {
    parameterPath: ["options", "include"],
    mapper: {
        serializedName: "$include",
        type: {
            name: "String"
        }
    }
};
const deletedShare = {
    parameterPath: "deletedShare",
    mapper: DeletedShare
};
const parameters10 = {
    parameterPath: ["options", "parameters"],
    mapper: LeaseShareRequest
};
const parameters11 = {
    parameterPath: "parameters",
    mapper: QueueServiceProperties
};
const queueServiceName = {
    parameterPath: "queueServiceName",
    mapper: {
        defaultValue: "default",
        isConstant: true,
        serializedName: "queueServiceName",
        type: {
            name: "String"
        }
    }
};
const queue = {
    parameterPath: "queue",
    mapper: StorageQueue
};
const queueName = {
    parameterPath: "queueName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-z0-9]([a-z0-9]|(-(?!-))){1,61}[a-z0-9]$"),
            MaxLength: 63,
            MinLength: 3
        },
        serializedName: "queueName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters12 = {
    parameterPath: "parameters",
    mapper: TableServiceProperties
};
const tableServiceName = {
    parameterPath: "tableServiceName",
    mapper: {
        defaultValue: "default",
        isConstant: true,
        serializedName: "tableServiceName",
        type: {
            name: "String"
        }
    }
};
const parameters13 = {
    parameterPath: ["options", "parameters"],
    mapper: Table
};
const tableName = {
    parameterPath: "tableName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[A-Za-z][A-Za-z0-9]{2,62}$"),
            MaxLength: 63,
            MinLength: 3
        },
        serializedName: "tableName",
        required: true,
        type: {
            name: "String"
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the available Storage Rest API operations.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the available Storage Rest API operations.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$g);
    }
}
// Operation Specifications
const serializer$j = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$g = {
    path: "/providers/Microsoft.Storage/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$j
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Skus operations. */
class SkusImpl {
    /**
     * Initialize a new instance of the class Skus class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the available SKUs supported by Microsoft.Storage for given subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists the available SKUs supported by Microsoft.Storage for given subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$f);
    }
}
// Operation Specifications
const serializer$i = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Storage/skus",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StorageSkuListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$i
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
function createLroSpec(inputs) {
    const { args, spec, sendOperationFn } = inputs;
    return {
        requestMethod: spec.httpMethod,
        requestPath: spec.path,
        sendInitialRequest: () => sendOperationFn(args, spec),
        sendPollRequest: (path, options) => {
            const restSpec = tslib.__rest(spec, ["requestBody"]);
            return sendOperationFn(args, Object.assign(Object.assign({}, restSpec), { httpMethod: "GET", path, abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal }));
        }
    };
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing StorageAccounts operations. */
class StorageAccountsImpl {
    /**
     * Initialize a new instance of the class StorageAccounts class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the storage accounts available under the subscription. Note that storage keys are not
     * returned; use the ListKeys operation for this.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the storage accounts available under the given resource group. Note that storage keys are
     * not returned; use the ListKeys operation for this.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Checks that the storage account name is valid and is not already in use.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    checkNameAvailability(accountName, options) {
        return this.client.sendOperationRequest({ accountName, options }, checkNameAvailabilityOperationSpec);
    }
    /**
     * Asynchronously creates a new storage account with the specified parameters. If an account is already
     * created and a subsequent create request is issued with different properties, the account properties
     * will be updated. If an account is already created and a subsequent create or update request is
     * issued with the exact same set of properties, the request will succeed.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param parameters The parameters to provide for the created account.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, accountName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, parameters, options },
                spec: createOperationSpec$4
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Asynchronously creates a new storage account with the specified parameters. If an account is already
     * created and a subsequent create request is issued with different properties, the account properties
     * will be updated. If an account is already created and a subsequent create or update request is
     * issued with the exact same set of properties, the request will succeed.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param parameters The parameters to provide for the created account.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, accountName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, accountName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a storage account in Microsoft Azure.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    delete(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, deleteOperationSpec$9);
    }
    /**
     * Returns the properties for the specified storage account including but not limited to name, SKU
     * name, location, and account status. The ListKeys operation should be used to retrieve storage keys.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    getProperties(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, getPropertiesOperationSpec);
    }
    /**
     * The update operation can be used to update the SKU, encryption, access tier, or tags for a storage
     * account. It can also be used to map the account to a custom domain. Only one custom domain is
     * supported per storage account; the replacement/change of custom domain is not supported. In order to
     * replace an old custom domain, the old value must be cleared/unregistered before a new value can be
     * set. The update of multiple properties is supported. This call does not change the storage keys for
     * the account. If you want to change the storage account keys, use the regenerate keys operation. The
     * location and name of the storage account cannot be changed after creation.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param parameters The parameters to provide for the updated account.
     * @param options The options parameters.
     */
    update(resourceGroupName, accountName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, parameters, options }, updateOperationSpec$4);
    }
    /**
     * Lists all the storage accounts available under the subscription. Note that storage keys are not
     * returned; use the ListKeys operation for this.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$e);
    }
    /**
     * Lists all the storage accounts available under the given resource group. Note that storage keys are
     * not returned; use the ListKeys operation for this.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * Lists the access keys or Kerberos keys (if active directory enabled) for the specified storage
     * account.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    listKeys(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listKeysOperationSpec$1);
    }
    /**
     * Regenerates one of the access keys or Kerberos keys for the specified storage account.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param regenerateKey Specifies name of the key which should be regenerated -- key1, key2, kerb1,
     *                      kerb2.
     * @param options The options parameters.
     */
    regenerateKey(resourceGroupName, accountName, regenerateKey, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, regenerateKey, options }, regenerateKeyOperationSpec);
    }
    /**
     * List SAS credentials of a storage account.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param parameters The parameters to provide to list SAS credentials for the storage account.
     * @param options The options parameters.
     */
    listAccountSAS(resourceGroupName, accountName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, parameters, options }, listAccountSASOperationSpec);
    }
    /**
     * List service SAS credentials of a specific resource.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param parameters The parameters to provide to list service SAS credentials.
     * @param options The options parameters.
     */
    listServiceSAS(resourceGroupName, accountName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, parameters, options }, listServiceSASOperationSpec);
    }
    /**
     * A failover request can be triggered for a storage account in the event a primary endpoint becomes
     * unavailable for any reason. The failover occurs from the storage account's primary cluster to the
     * secondary cluster for RA-GRS accounts. The secondary cluster will become primary after failover and
     * the account is converted to LRS. In the case of a Planned Failover, the primary and secondary
     * clusters are swapped after failover and the account remains geo-replicated. Failover should continue
     * to be used in the event of availability issues as Planned failover is only available while the
     * primary and secondary endpoints are available. The primary use case of a Planned Failover is
     * disaster recovery testing drills. This type of failover is invoked by setting FailoverType parameter
     * to 'Planned'. Learn more about the failover options here-
     * https://learn.microsoft.com/azure/storage/common/storage-disaster-recovery-guidance
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    beginFailover(resourceGroupName, accountName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, options },
                spec: failoverOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * A failover request can be triggered for a storage account in the event a primary endpoint becomes
     * unavailable for any reason. The failover occurs from the storage account's primary cluster to the
     * secondary cluster for RA-GRS accounts. The secondary cluster will become primary after failover and
     * the account is converted to LRS. In the case of a Planned Failover, the primary and secondary
     * clusters are swapped after failover and the account remains geo-replicated. Failover should continue
     * to be used in the event of availability issues as Planned failover is only available while the
     * primary and secondary endpoints are available. The primary use case of a Planned Failover is
     * disaster recovery testing drills. This type of failover is invoked by setting FailoverType parameter
     * to 'Planned'. Learn more about the failover options here-
     * https://learn.microsoft.com/azure/storage/common/storage-disaster-recovery-guidance
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    beginFailoverAndWait(resourceGroupName, accountName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginFailover(resourceGroupName, accountName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Live Migration of storage account to enable Hns
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param requestType Required. Hierarchical namespace migration type can either be a hierarchical
     *                    namespace validation request 'HnsOnValidationRequest' or a hydration request
     *                    'HnsOnHydrationRequest'. The validation request will validate the migration whereas the hydration
     *                    request will migrate the account.
     * @param options The options parameters.
     */
    beginHierarchicalNamespaceMigration(resourceGroupName, accountName, requestType, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, requestType, options },
                spec: hierarchicalNamespaceMigrationOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Live Migration of storage account to enable Hns
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param requestType Required. Hierarchical namespace migration type can either be a hierarchical
     *                    namespace validation request 'HnsOnValidationRequest' or a hydration request
     *                    'HnsOnHydrationRequest'. The validation request will validate the migration whereas the hydration
     *                    request will migrate the account.
     * @param options The options parameters.
     */
    beginHierarchicalNamespaceMigrationAndWait(resourceGroupName, accountName, requestType, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginHierarchicalNamespaceMigration(resourceGroupName, accountName, requestType, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Abort live Migration of storage account to enable Hns
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    beginAbortHierarchicalNamespaceMigration(resourceGroupName, accountName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, options },
                spec: abortHierarchicalNamespaceMigrationOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Abort live Migration of storage account to enable Hns
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    beginAbortHierarchicalNamespaceMigrationAndWait(resourceGroupName, accountName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginAbortHierarchicalNamespaceMigration(resourceGroupName, accountName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Account Migration request can be triggered for a storage account to change its redundancy level. The
     * migration updates the non-zonal redundant storage account to a zonal redundant account or vice-versa
     * in order to have better reliability and availability. Zone-redundant storage (ZRS) replicates your
     * storage account synchronously across three Azure availability zones in the primary region.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param parameters The request parameters required to perform storage account migration.
     * @param options The options parameters.
     */
    beginCustomerInitiatedMigration(resourceGroupName, accountName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, parameters, options },
                spec: customerInitiatedMigrationOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Account Migration request can be triggered for a storage account to change its redundancy level. The
     * migration updates the non-zonal redundant storage account to a zonal redundant account or vice-versa
     * in order to have better reliability and availability. Zone-redundant storage (ZRS) replicates your
     * storage account synchronously across three Azure availability zones in the primary region.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param parameters The request parameters required to perform storage account migration.
     * @param options The options parameters.
     */
    beginCustomerInitiatedMigrationAndWait(resourceGroupName, accountName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCustomerInitiatedMigration(resourceGroupName, accountName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the status of the ongoing migration for the specified storage account.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param migrationName The name of the Storage Account Migration. It should always be 'default'
     * @param options The options parameters.
     */
    getCustomerInitiatedMigration(resourceGroupName, accountName, migrationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, migrationName, options }, getCustomerInitiatedMigrationOperationSpec);
    }
    /**
     * Restore blobs in the specified blob ranges
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param parameters The parameters to provide for restore blob ranges.
     * @param options The options parameters.
     */
    beginRestoreBlobRanges(resourceGroupName, accountName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, parameters, options },
                spec: restoreBlobRangesOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Restore blobs in the specified blob ranges
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param parameters The parameters to provide for restore blob ranges.
     * @param options The options parameters.
     */
    beginRestoreBlobRangesAndWait(resourceGroupName, accountName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRestoreBlobRanges(resourceGroupName, accountName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Revoke user delegation keys.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    revokeUserDelegationKeys(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, revokeUserDelegationKeysOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$6);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
}
// Operation Specifications
const serializer$h = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const checkNameAvailabilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Storage/checkNameAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CheckNameAvailabilityResult
        }
    },
    requestBody: accountName,
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$h
};
const createOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StorageAccount
        },
        201: {
            bodyMapper: StorageAccount
        },
        202: {
            bodyMapper: StorageAccount
        },
        204: {
            bodyMapper: StorageAccount
        }
    },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$h
};
const deleteOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 204: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1
    ],
    serializer: serializer$h
};
const getPropertiesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StorageAccount
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const updateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: StorageAccount
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$h
};
const listOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Storage/storageAccounts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StorageAccountListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$h
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StorageAccountListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const listKeysOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/listKeys",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: StorageAccountListKeysResult
        }
    },
    queryParameters: [apiVersion, expand1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const regenerateKeyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/regenerateKey",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: StorageAccountListKeysResult
        }
    },
    requestBody: regenerateKey,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$h
};
const listAccountSASOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/ListAccountSas",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ListAccountSasResponse
        }
    },
    requestBody: parameters2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$h
};
const listServiceSASOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/ListServiceSas",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ListServiceSasResponse
        }
    },
    requestBody: parameters3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$h
};
const failoverOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/failover",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {} },
    queryParameters: [apiVersion, failoverType],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1
    ],
    serializer: serializer$h
};
const hierarchicalNamespaceMigrationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/hnsonmigration",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, requestType],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const abortHierarchicalNamespaceMigrationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/aborthnsonmigration",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const customerInitiatedMigrationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/startAccountMigration",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponseAutoGenerated
        }
    },
    requestBody: parameters4,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$h
};
const getCustomerInitiatedMigrationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/accountMigrations/{migrationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StorageAccountMigration
        },
        default: {
            bodyMapper: ErrorResponseAutoGenerated
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        migrationName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const restoreBlobRangesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/restoreBlobRanges",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BlobRestoreStatus
        },
        201: {
            bodyMapper: BlobRestoreStatus
        },
        202: {
            bodyMapper: BlobRestoreStatus
        },
        204: {
            bodyMapper: BlobRestoreStatus
        }
    },
    requestBody: parameters5,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$h
};
const revokeUserDelegationKeysOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/revokeUserDelegationKeys",
    httpMethod: "POST",
    responses: { 200: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName2
    ],
    serializer: serializer$h
};
const listNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StorageAccountListResult
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StorageAccountListResult
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$h
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DeletedAccounts operations. */
class DeletedAccountsImpl {
    /**
     * Initialize a new instance of the class DeletedAccounts class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists deleted accounts under the subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists deleted accounts under the subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$d);
    }
    /**
     * Get properties of specified deleted account resource.
     * @param deletedAccountName Name of the deleted storage account.
     * @param location The location of the deleted storage account.
     * @param options The options parameters.
     */
    get(deletedAccountName, location, options) {
        return this.client.sendOperationRequest({ deletedAccountName, location, options }, getOperationSpec$a);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$5);
    }
}
// Operation Specifications
const serializer$g = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Storage/deletedAccounts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedAccountListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$g
};
const getOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Storage/locations/{location}/deletedAccounts/{deletedAccountName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedAccount
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        deletedAccountName,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const listNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedAccountListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$g
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Usages operations. */
class UsagesImpl {
    /**
     * Initialize a new instance of the class Usages class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the current usage count and the limit for the resources of the location under the subscription.
     * @param location The location of the Azure Storage resource.
     * @param options The options parameters.
     */
    listByLocation(location, options) {
        const iter = this.listByLocationPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByLocationPagingPage(location, options, settings);
            }
        };
    }
    listByLocationPagingPage(location, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByLocationPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listByLocation(location, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listByLocationPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByLocationPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByLocationPagingPage(location, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the current usage count and the limit for the resources of the location under the subscription.
     * @param location The location of the Azure Storage resource.
     * @param options The options parameters.
     */
    _listByLocation(location, options) {
        return this.client.sendOperationRequest({ location, options }, listByLocationOperationSpec);
    }
}
// Operation Specifications
const serializer$f = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByLocationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Storage/locations/{location}/usages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UsageListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$f
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ManagementPolicies operations. */
class ManagementPoliciesImpl {
    /**
     * Initialize a new instance of the class ManagementPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the managementpolicy associated with the specified storage account.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param managementPolicyName The name of the Storage Account Management Policy. It should always be
     *                             'default'
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, managementPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, managementPolicyName, options }, getOperationSpec$9);
    }
    /**
     * Sets the managementpolicy to the specified storage account.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param managementPolicyName The name of the Storage Account Management Policy. It should always be
     *                             'default'
     * @param properties The ManagementPolicy set to a storage account.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, accountName, managementPolicyName, properties, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            accountName,
            managementPolicyName,
            properties,
            options
        }, createOrUpdateOperationSpec$3);
    }
    /**
     * Deletes the managementpolicy associated with the specified storage account.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param managementPolicyName The name of the Storage Account Management Policy. It should always be
     *                             'default'
     * @param options The options parameters.
     */
    delete(resourceGroupName, accountName, managementPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, managementPolicyName, options }, deleteOperationSpec$8);
    }
}
// Operation Specifications
const serializer$e = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/managementPolicies/{managementPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagementPolicy
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        managementPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const createOrUpdateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/managementPolicies/{managementPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ManagementPolicy
        }
    },
    requestBody: properties,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        managementPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$e
};
const deleteOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/managementPolicies/{managementPolicyName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 204: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        managementPolicyName
    ],
    serializer: serializer$e
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing BlobInventoryPolicies operations. */
class BlobInventoryPoliciesImpl {
    /**
     * Initialize a new instance of the class BlobInventoryPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the blob inventory policy associated with the specified storage account.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    list(resourceGroupName, accountName, options) {
        const iter = this.listPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, accountName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(resourceGroupName, accountName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, accountName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the blob inventory policy associated with the specified storage account.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param blobInventoryPolicyName The name of the storage account blob inventory policy. It should
     *                                always be 'default'
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, blobInventoryPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, blobInventoryPolicyName, options }, getOperationSpec$8);
    }
    /**
     * Sets the blob inventory policy to the specified storage account.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param blobInventoryPolicyName The name of the storage account blob inventory policy. It should
     *                                always be 'default'
     * @param properties The blob inventory policy set to a storage account.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, accountName, blobInventoryPolicyName, properties, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            accountName,
            blobInventoryPolicyName,
            properties,
            options
        }, createOrUpdateOperationSpec$2);
    }
    /**
     * Deletes the blob inventory policy associated with the specified storage account.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param blobInventoryPolicyName The name of the storage account blob inventory policy. It should
     *                                always be 'default'
     * @param options The options parameters.
     */
    delete(resourceGroupName, accountName, blobInventoryPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, blobInventoryPolicyName, options }, deleteOperationSpec$7);
    }
    /**
     * Gets the blob inventory policy associated with the specified storage account.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    _list(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listOperationSpec$c);
    }
}
// Operation Specifications
const serializer$d = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/inventoryPolicies/{blobInventoryPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BlobInventoryPolicy
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        blobInventoryPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/inventoryPolicies/{blobInventoryPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: BlobInventoryPolicy
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: properties1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        blobInventoryPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$d
};
const deleteOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/inventoryPolicies/{blobInventoryPolicyName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        blobInventoryPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/inventoryPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListBlobInventoryPolicy
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1
    ],
    headerParameters: [accept],
    serializer: serializer$d
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateEndpointConnections operations. */
class PrivateEndpointConnectionsImpl {
    /**
     * Initialize a new instance of the class PrivateEndpointConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all the private endpoint connections associated with the storage account.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    list(resourceGroupName, accountName, options) {
        const iter = this.listPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, accountName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(resourceGroupName, accountName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, accountName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List all the private endpoint connections associated with the storage account.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    _list(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listOperationSpec$b);
    }
    /**
     * Gets the specified private endpoint connection associated with the storage account.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param privateEndpointConnectionName The name of the private endpoint connection associated with the
     *                                      Azure resource
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, privateEndpointConnectionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            accountName,
            privateEndpointConnectionName,
            options
        }, getOperationSpec$7);
    }
    /**
     * Update the state of specified private endpoint connection associated with the storage account.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param privateEndpointConnectionName The name of the private endpoint connection associated with the
     *                                      Azure resource
     * @param properties The private endpoint connection properties.
     * @param options The options parameters.
     */
    put(resourceGroupName, accountName, privateEndpointConnectionName, properties, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            accountName,
            privateEndpointConnectionName,
            properties,
            options
        }, putOperationSpec$1);
    }
    /**
     * Deletes the specified private endpoint connection associated with the storage account.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param privateEndpointConnectionName The name of the private endpoint connection associated with the
     *                                      Azure resource
     * @param options The options parameters.
     */
    delete(resourceGroupName, accountName, privateEndpointConnectionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            accountName,
            privateEndpointConnectionName,
            options
        }, deleteOperationSpec$6);
    }
}
// Operation Specifications
const serializer$c = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/privateEndpointConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const getOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        privateEndpointConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const putOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: properties2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        privateEndpointConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$c
};
const deleteOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        privateEndpointConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing PrivateLinkResources operations. */
class PrivateLinkResourcesImpl {
    /**
     * Initialize a new instance of the class PrivateLinkResources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the private link resources that need to be created for a storage account.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    listByStorageAccount(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listByStorageAccountOperationSpec);
    }
}
// Operation Specifications
const serializer$b = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByStorageAccountOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/privateLinkResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResourceListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1
    ],
    headerParameters: [accept],
    serializer: serializer$b
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ObjectReplicationPoliciesOperations operations. */
class ObjectReplicationPoliciesOperationsImpl {
    /**
     * Initialize a new instance of the class ObjectReplicationPoliciesOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List the object replication policies associated with the storage account.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    list(resourceGroupName, accountName, options) {
        const iter = this.listPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, accountName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(resourceGroupName, accountName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, accountName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List the object replication policies associated with the storage account.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    _list(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listOperationSpec$a);
    }
    /**
     * Get the object replication policy of the storage account by policy ID.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param objectReplicationPolicyId For the destination account, provide the value 'default'. Configure
     *                                  the policy on the destination account first. For the source account, provide the value of the policy
     *                                  ID that is returned when you download the policy that was defined on the destination account. The
     *                                  policy is downloaded as a JSON file.
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, objectReplicationPolicyId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, objectReplicationPolicyId, options }, getOperationSpec$6);
    }
    /**
     * Create or update the object replication policy of the storage account.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param objectReplicationPolicyId For the destination account, provide the value 'default'. Configure
     *                                  the policy on the destination account first. For the source account, provide the value of the policy
     *                                  ID that is returned when you download the policy that was defined on the destination account. The
     *                                  policy is downloaded as a JSON file.
     * @param properties The object replication policy set to a storage account. A unique policy ID will be
     *                   created if absent.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, accountName, objectReplicationPolicyId, properties, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            accountName,
            objectReplicationPolicyId,
            properties,
            options
        }, createOrUpdateOperationSpec$1);
    }
    /**
     * Deletes the object replication policy associated with the specified storage account.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param objectReplicationPolicyId For the destination account, provide the value 'default'. Configure
     *                                  the policy on the destination account first. For the source account, provide the value of the policy
     *                                  ID that is returned when you download the policy that was defined on the destination account. The
     *                                  policy is downloaded as a JSON file.
     * @param options The options parameters.
     */
    delete(resourceGroupName, accountName, objectReplicationPolicyId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, objectReplicationPolicyId, options }, deleteOperationSpec$5);
    }
}
// Operation Specifications
const serializer$a = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/objectReplicationPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ObjectReplicationPolicies
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/objectReplicationPolicies/{objectReplicationPolicyId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ObjectReplicationPolicy
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        objectReplicationPolicyId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/objectReplicationPolicies/{objectReplicationPolicyId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ObjectReplicationPolicy
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: properties3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        objectReplicationPolicyId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deleteOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/objectReplicationPolicies/{objectReplicationPolicyId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        objectReplicationPolicyId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing LocalUsersOperations operations. */
class LocalUsersOperationsImpl {
    /**
     * Initialize a new instance of the class LocalUsersOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List the local users associated with the storage account.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    list(resourceGroupName, accountName, options) {
        const iter = this.listPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, accountName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(resourceGroupName, accountName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, accountName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List the local users associated with the storage account.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    _list(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listOperationSpec$9);
    }
    /**
     * Get the local user of the storage account by username.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param username The name of local user. The username must contain lowercase letters and numbers
     *                 only. It must be unique only within the storage account.
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, username, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, username, options }, getOperationSpec$5);
    }
    /**
     * Create or update the properties of a local user associated with the storage account
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param username The name of local user. The username must contain lowercase letters and numbers
     *                 only. It must be unique only within the storage account.
     * @param properties The local user associated with a storage account.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, accountName, username, properties, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, username, properties, options }, createOrUpdateOperationSpec);
    }
    /**
     * Deletes the local user associated with the specified storage account.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param username The name of local user. The username must contain lowercase letters and numbers
     *                 only. It must be unique only within the storage account.
     * @param options The options parameters.
     */
    delete(resourceGroupName, accountName, username, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, username, options }, deleteOperationSpec$4);
    }
    /**
     * List SSH authorized keys and shared key of the local user.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param username The name of local user. The username must contain lowercase letters and numbers
     *                 only. It must be unique only within the storage account.
     * @param options The options parameters.
     */
    listKeys(resourceGroupName, accountName, username, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, username, options }, listKeysOperationSpec);
    }
    /**
     * Regenerate the local user SSH password.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param username The name of local user. The username must contain lowercase letters and numbers
     *                 only. It must be unique only within the storage account.
     * @param options The options parameters.
     */
    regeneratePassword(resourceGroupName, accountName, username, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, username, options }, regeneratePasswordOperationSpec);
    }
}
// Operation Specifications
const serializer$9 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/localUsers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LocalUsers
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const getOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/localUsers/{username}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LocalUser
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        username
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/localUsers/{username}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: LocalUser
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: properties4,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        username
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9
};
const deleteOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/localUsers/{username}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        username
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listKeysOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/localUsers/{username}/listKeys",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: LocalUserKeys
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        username
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const regeneratePasswordOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/localUsers/{username}/regeneratePassword",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: LocalUserRegeneratePasswordResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        username
    ],
    headerParameters: [accept],
    serializer: serializer$9
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing EncryptionScopes operations. */
class EncryptionScopesImpl {
    /**
     * Initialize a new instance of the class EncryptionScopes class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the encryption scopes available under the specified storage account.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    list(resourceGroupName, accountName, options) {
        const iter = this.listPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, accountName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, accountName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, accountName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, accountName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Synchronously creates or updates an encryption scope under the specified storage account. If an
     * encryption scope is already created and a subsequent request is issued with different properties,
     * the encryption scope properties will be updated per the specified request.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param encryptionScopeName The name of the encryption scope within the specified storage account.
     *                            Encryption scope names must be between 3 and 63 characters in length and use numbers, lower-case
     *                            letters and dash (-) only. Every dash (-) character must be immediately preceded and followed by a
     *                            letter or number.
     * @param encryptionScope Encryption scope properties to be used for the create or update.
     * @param options The options parameters.
     */
    put(resourceGroupName, accountName, encryptionScopeName, encryptionScope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            accountName,
            encryptionScopeName,
            encryptionScope,
            options
        }, putOperationSpec);
    }
    /**
     * Update encryption scope properties as specified in the request body. Update fails if the specified
     * encryption scope does not already exist.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param encryptionScopeName The name of the encryption scope within the specified storage account.
     *                            Encryption scope names must be between 3 and 63 characters in length and use numbers, lower-case
     *                            letters and dash (-) only. Every dash (-) character must be immediately preceded and followed by a
     *                            letter or number.
     * @param encryptionScope Encryption scope properties to be used for the update.
     * @param options The options parameters.
     */
    patch(resourceGroupName, accountName, encryptionScopeName, encryptionScope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            accountName,
            encryptionScopeName,
            encryptionScope,
            options
        }, patchOperationSpec);
    }
    /**
     * Returns the properties for the specified encryption scope.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param encryptionScopeName The name of the encryption scope within the specified storage account.
     *                            Encryption scope names must be between 3 and 63 characters in length and use numbers, lower-case
     *                            letters and dash (-) only. Every dash (-) character must be immediately preceded and followed by a
     *                            letter or number.
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, encryptionScopeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, encryptionScopeName, options }, getOperationSpec$4);
    }
    /**
     * Lists all the encryption scopes available under the specified storage account.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    _list(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listOperationSpec$8);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, accountName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, nextLink, options }, listNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$8 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const putOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/encryptionScopes/{encryptionScopeName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: EncryptionScope
        },
        201: {
            bodyMapper: EncryptionScope
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: encryptionScope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        encryptionScopeName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8
};
const patchOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/encryptionScopes/{encryptionScopeName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: EncryptionScope
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: encryptionScope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        encryptionScopeName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8
};
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/encryptionScopes/{encryptionScopeName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EncryptionScope
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        encryptionScopeName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/encryptionScopes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EncryptionScopeListResult
        }
    },
    queryParameters: [
        apiVersion,
        maxpagesize,
        filter,
        include
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EncryptionScopeListResult
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing BlobServices operations. */
class BlobServicesImpl {
    /**
     * Initialize a new instance of the class BlobServices class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List blob services of storage account. It returns a collection of one object named default.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    list(resourceGroupName, accountName, options) {
        const iter = this.listPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, accountName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(resourceGroupName, accountName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, accountName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List blob services of storage account. It returns a collection of one object named default.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    _list(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listOperationSpec$7);
    }
    /**
     * Sets the properties of a storage account’s Blob service, including properties for Storage Analytics
     * and CORS (Cross-Origin Resource Sharing) rules.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param parameters The properties of a storage account’s Blob service, including properties for
     *                   Storage Analytics and CORS (Cross-Origin Resource Sharing) rules.
     * @param options The options parameters.
     */
    setServiceProperties(resourceGroupName, accountName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, parameters, options }, setServicePropertiesOperationSpec$3);
    }
    /**
     * Gets the properties of a storage account’s Blob service, including properties for Storage Analytics
     * and CORS (Cross-Origin Resource Sharing) rules.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    getServiceProperties(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, getServicePropertiesOperationSpec$3);
    }
}
// Operation Specifications
const serializer$7 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BlobServiceItems
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const setServicePropertiesOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/{BlobServicesName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: BlobServiceProperties
        }
    },
    requestBody: parameters6,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        blobServicesName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const getServicePropertiesOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/{BlobServicesName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BlobServiceProperties
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        blobServicesName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing BlobContainers operations. */
class BlobContainersImpl {
    /**
     * Initialize a new instance of the class BlobContainers class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all containers and does not support a prefix like data plane. Also SRP today does not return
     * continuation token.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    list(resourceGroupName, accountName, options) {
        const iter = this.listPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, accountName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, accountName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, accountName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, accountName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all containers and does not support a prefix like data plane. Also SRP today does not return
     * continuation token.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    _list(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listOperationSpec$6);
    }
    /**
     * Creates a new container under the specified account as described by request body. The container
     * resource includes metadata and properties for that container. It does not include a list of the
     * blobs contained by the container.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param containerName The name of the blob container within the specified storage account. Blob
     *                      container names must be between 3 and 63 characters in length and use numbers, lower-case letters
     *                      and dash (-) only. Every dash (-) character must be immediately preceded and followed by a letter or
     *                      number.
     * @param blobContainer Properties of the blob container to create.
     * @param options The options parameters.
     */
    create(resourceGroupName, accountName, containerName, blobContainer, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, containerName, blobContainer, options }, createOperationSpec$3);
    }
    /**
     * Updates container properties as specified in request body. Properties not mentioned in the request
     * will be unchanged. Update fails if the specified container doesn't already exist.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param containerName The name of the blob container within the specified storage account. Blob
     *                      container names must be between 3 and 63 characters in length and use numbers, lower-case letters
     *                      and dash (-) only. Every dash (-) character must be immediately preceded and followed by a letter or
     *                      number.
     * @param blobContainer Properties to update for the blob container.
     * @param options The options parameters.
     */
    update(resourceGroupName, accountName, containerName, blobContainer, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, containerName, blobContainer, options }, updateOperationSpec$3);
    }
    /**
     * Gets properties of a specified container.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param containerName The name of the blob container within the specified storage account. Blob
     *                      container names must be between 3 and 63 characters in length and use numbers, lower-case letters
     *                      and dash (-) only. Every dash (-) character must be immediately preceded and followed by a letter or
     *                      number.
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, containerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, containerName, options }, getOperationSpec$3);
    }
    /**
     * Deletes specified container under its account.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param containerName The name of the blob container within the specified storage account. Blob
     *                      container names must be between 3 and 63 characters in length and use numbers, lower-case letters
     *                      and dash (-) only. Every dash (-) character must be immediately preceded and followed by a letter or
     *                      number.
     * @param options The options parameters.
     */
    delete(resourceGroupName, accountName, containerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, containerName, options }, deleteOperationSpec$3);
    }
    /**
     * Sets legal hold tags. Setting the same tag results in an idempotent operation. SetLegalHold follows
     * an append pattern and does not clear out the existing tags that are not specified in the request.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param containerName The name of the blob container within the specified storage account. Blob
     *                      container names must be between 3 and 63 characters in length and use numbers, lower-case letters
     *                      and dash (-) only. Every dash (-) character must be immediately preceded and followed by a letter or
     *                      number.
     * @param legalHold The LegalHold property that will be set to a blob container.
     * @param options The options parameters.
     */
    setLegalHold(resourceGroupName, accountName, containerName, legalHold, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, containerName, legalHold, options }, setLegalHoldOperationSpec);
    }
    /**
     * Clears legal hold tags. Clearing the same or non-existent tag results in an idempotent operation.
     * ClearLegalHold clears out only the specified tags in the request.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param containerName The name of the blob container within the specified storage account. Blob
     *                      container names must be between 3 and 63 characters in length and use numbers, lower-case letters
     *                      and dash (-) only. Every dash (-) character must be immediately preceded and followed by a letter or
     *                      number.
     * @param legalHold The LegalHold property that will be clear from a blob container.
     * @param options The options parameters.
     */
    clearLegalHold(resourceGroupName, accountName, containerName, legalHold, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, containerName, legalHold, options }, clearLegalHoldOperationSpec);
    }
    /**
     * Creates or updates an unlocked immutability policy. ETag in If-Match is honored if given but not
     * required for this operation.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param containerName The name of the blob container within the specified storage account. Blob
     *                      container names must be between 3 and 63 characters in length and use numbers, lower-case letters
     *                      and dash (-) only. Every dash (-) character must be immediately preceded and followed by a letter or
     *                      number.
     * @param options The options parameters.
     */
    createOrUpdateImmutabilityPolicy(resourceGroupName, accountName, containerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, containerName, options }, createOrUpdateImmutabilityPolicyOperationSpec);
    }
    /**
     * Gets the existing immutability policy along with the corresponding ETag in response headers and
     * body.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param containerName The name of the blob container within the specified storage account. Blob
     *                      container names must be between 3 and 63 characters in length and use numbers, lower-case letters
     *                      and dash (-) only. Every dash (-) character must be immediately preceded and followed by a letter or
     *                      number.
     * @param options The options parameters.
     */
    getImmutabilityPolicy(resourceGroupName, accountName, containerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, containerName, options }, getImmutabilityPolicyOperationSpec);
    }
    /**
     * Aborts an unlocked immutability policy. The response of delete has
     * immutabilityPeriodSinceCreationInDays set to 0. ETag in If-Match is required for this operation.
     * Deleting a locked immutability policy is not allowed, the only way is to delete the container after
     * deleting all expired blobs inside the policy locked container.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param containerName The name of the blob container within the specified storage account. Blob
     *                      container names must be between 3 and 63 characters in length and use numbers, lower-case letters
     *                      and dash (-) only. Every dash (-) character must be immediately preceded and followed by a letter or
     *                      number.
     * @param ifMatch The entity state (ETag) version of the immutability policy to update. A value of "*"
     *                can be used to apply the operation only if the immutability policy already exists. If omitted, this
     *                operation will always be applied.
     * @param options The options parameters.
     */
    deleteImmutabilityPolicy(resourceGroupName, accountName, containerName, ifMatch, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, containerName, ifMatch, options }, deleteImmutabilityPolicyOperationSpec);
    }
    /**
     * Sets the ImmutabilityPolicy to Locked state. The only action allowed on a Locked policy is
     * ExtendImmutabilityPolicy action. ETag in If-Match is required for this operation.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param containerName The name of the blob container within the specified storage account. Blob
     *                      container names must be between 3 and 63 characters in length and use numbers, lower-case letters
     *                      and dash (-) only. Every dash (-) character must be immediately preceded and followed by a letter or
     *                      number.
     * @param ifMatch The entity state (ETag) version of the immutability policy to update. A value of "*"
     *                can be used to apply the operation only if the immutability policy already exists. If omitted, this
     *                operation will always be applied.
     * @param options The options parameters.
     */
    lockImmutabilityPolicy(resourceGroupName, accountName, containerName, ifMatch, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, containerName, ifMatch, options }, lockImmutabilityPolicyOperationSpec);
    }
    /**
     * Extends the immutabilityPeriodSinceCreationInDays of a locked immutabilityPolicy. The only action
     * allowed on a Locked policy will be this action. ETag in If-Match is required for this operation.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param containerName The name of the blob container within the specified storage account. Blob
     *                      container names must be between 3 and 63 characters in length and use numbers, lower-case letters
     *                      and dash (-) only. Every dash (-) character must be immediately preceded and followed by a letter or
     *                      number.
     * @param ifMatch The entity state (ETag) version of the immutability policy to update. A value of "*"
     *                can be used to apply the operation only if the immutability policy already exists. If omitted, this
     *                operation will always be applied.
     * @param options The options parameters.
     */
    extendImmutabilityPolicy(resourceGroupName, accountName, containerName, ifMatch, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, containerName, ifMatch, options }, extendImmutabilityPolicyOperationSpec);
    }
    /**
     * The Lease Container operation establishes and manages a lock on a container for delete operations.
     * The lock duration can be 15 to 60 seconds, or can be infinite.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param containerName The name of the blob container within the specified storage account. Blob
     *                      container names must be between 3 and 63 characters in length and use numbers, lower-case letters
     *                      and dash (-) only. Every dash (-) character must be immediately preceded and followed by a letter or
     *                      number.
     * @param options The options parameters.
     */
    lease(resourceGroupName, accountName, containerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, containerName, options }, leaseOperationSpec$1);
    }
    /**
     * This operation migrates a blob container from container level WORM to object level immutability
     * enabled container. Prerequisites require a container level immutability policy either in locked or
     * unlocked state, Account level versioning must be enabled and there should be no Legal hold on the
     * container.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param containerName The name of the blob container within the specified storage account. Blob
     *                      container names must be between 3 and 63 characters in length and use numbers, lower-case letters
     *                      and dash (-) only. Every dash (-) character must be immediately preceded and followed by a letter or
     *                      number.
     * @param options The options parameters.
     */
    beginObjectLevelWorm(resourceGroupName, accountName, containerName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, containerName, options },
                spec: objectLevelWormOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * This operation migrates a blob container from container level WORM to object level immutability
     * enabled container. Prerequisites require a container level immutability policy either in locked or
     * unlocked state, Account level versioning must be enabled and there should be no Legal hold on the
     * container.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param containerName The name of the blob container within the specified storage account. Blob
     *                      container names must be between 3 and 63 characters in length and use numbers, lower-case letters
     *                      and dash (-) only. Every dash (-) character must be immediately preceded and followed by a letter or
     *                      number.
     * @param options The options parameters.
     */
    beginObjectLevelWormAndWait(resourceGroupName, accountName, containerName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginObjectLevelWorm(resourceGroupName, accountName, containerName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, accountName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, nextLink, options }, listNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListContainerItems
        }
    },
    queryParameters: [
        apiVersion,
        filter,
        maxpagesize1,
        include1
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const createOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: BlobContainer
        },
        201: {
            bodyMapper: BlobContainer
        }
    },
    requestBody: blobContainer,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        containerName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const updateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: BlobContainer
        }
    },
    requestBody: blobContainer,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        containerName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BlobContainer
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        containerName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 204: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        containerName
    ],
    serializer: serializer$6
};
const setLegalHoldOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}/setLegalHold",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: LegalHold
        }
    },
    requestBody: legalHold,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        containerName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const clearLegalHoldOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}/clearLegalHold",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: LegalHold
        }
    },
    requestBody: legalHold,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        containerName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const createOrUpdateImmutabilityPolicyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}/immutabilityPolicies/{immutabilityPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ImmutabilityPolicy,
            headersMapper: BlobContainersCreateOrUpdateImmutabilityPolicyHeaders
        }
    },
    requestBody: parameters7,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        containerName,
        immutabilityPolicyName
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$6
};
const getImmutabilityPolicyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}/immutabilityPolicies/{immutabilityPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ImmutabilityPolicy,
            headersMapper: BlobContainersGetImmutabilityPolicyHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        containerName,
        immutabilityPolicyName
    ],
    headerParameters: [accept, ifMatch],
    serializer: serializer$6
};
const deleteImmutabilityPolicyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}/immutabilityPolicies/{immutabilityPolicyName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            bodyMapper: ImmutabilityPolicy,
            headersMapper: BlobContainersDeleteImmutabilityPolicyHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        containerName,
        immutabilityPolicyName
    ],
    headerParameters: [accept, ifMatch1],
    serializer: serializer$6
};
const lockImmutabilityPolicyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}/immutabilityPolicies/default/lock",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ImmutabilityPolicy,
            headersMapper: BlobContainersLockImmutabilityPolicyHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        containerName
    ],
    headerParameters: [accept, ifMatch1],
    serializer: serializer$6
};
const extendImmutabilityPolicyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}/immutabilityPolicies/default/extend",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ImmutabilityPolicy,
            headersMapper: BlobContainersExtendImmutabilityPolicyHeaders
        }
    },
    requestBody: parameters7,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        containerName
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch1
    ],
    mediaType: "json",
    serializer: serializer$6
};
const leaseOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}/lease",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: LeaseContainerResponse
        }
    },
    requestBody: parameters8,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        containerName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const objectLevelWormOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}/migrate",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        containerName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListContainerItems
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing FileServices operations. */
class FileServicesImpl {
    /**
     * Initialize a new instance of the class FileServices class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all file services in storage accounts
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    list(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listOperationSpec$5);
    }
    /**
     * Sets the properties of file services in storage accounts, including CORS (Cross-Origin Resource
     * Sharing) rules.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param parameters The properties of file services in storage accounts, including CORS (Cross-Origin
     *                   Resource Sharing) rules.
     * @param options The options parameters.
     */
    setServiceProperties(resourceGroupName, accountName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, parameters, options }, setServicePropertiesOperationSpec$2);
    }
    /**
     * Gets the properties of file services in storage accounts, including CORS (Cross-Origin Resource
     * Sharing) rules.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    getServiceProperties(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, getServicePropertiesOperationSpec$2);
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/fileServices",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FileServiceItems
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const setServicePropertiesOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/fileServices/{FileServicesName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: FileServiceProperties
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters9,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        fileServicesName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$5
};
const getServicePropertiesOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/fileServices/{FileServicesName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FileServiceProperties
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        fileServicesName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing FileShares operations. */
class FileSharesImpl {
    /**
     * Initialize a new instance of the class FileShares class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all shares.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    list(resourceGroupName, accountName, options) {
        const iter = this.listPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, accountName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, accountName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, accountName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, accountName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all shares.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    _list(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listOperationSpec$4);
    }
    /**
     * Creates a new share under the specified account as described by request body. The share resource
     * includes metadata and properties for that share. It does not include a list of the files contained
     * by the share.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param shareName The name of the file share within the specified storage account. File share names
     *                  must be between 3 and 63 characters in length and use numbers, lower-case letters and dash (-) only.
     *                  Every dash (-) character must be immediately preceded and followed by a letter or number.
     * @param fileShare Properties of the file share to create.
     * @param options The options parameters.
     */
    create(resourceGroupName, accountName, shareName, fileShare, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, shareName, fileShare, options }, createOperationSpec$2);
    }
    /**
     * Updates share properties as specified in request body. Properties not mentioned in the request will
     * not be changed. Update fails if the specified share does not already exist.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param shareName The name of the file share within the specified storage account. File share names
     *                  must be between 3 and 63 characters in length and use numbers, lower-case letters and dash (-) only.
     *                  Every dash (-) character must be immediately preceded and followed by a letter or number.
     * @param fileShare Properties to update for the file share.
     * @param options The options parameters.
     */
    update(resourceGroupName, accountName, shareName, fileShare, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, shareName, fileShare, options }, updateOperationSpec$2);
    }
    /**
     * Gets properties of a specified share.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param shareName The name of the file share within the specified storage account. File share names
     *                  must be between 3 and 63 characters in length and use numbers, lower-case letters and dash (-) only.
     *                  Every dash (-) character must be immediately preceded and followed by a letter or number.
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, shareName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, shareName, options }, getOperationSpec$2);
    }
    /**
     * Deletes specified share under its account.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param shareName The name of the file share within the specified storage account. File share names
     *                  must be between 3 and 63 characters in length and use numbers, lower-case letters and dash (-) only.
     *                  Every dash (-) character must be immediately preceded and followed by a letter or number.
     * @param options The options parameters.
     */
    delete(resourceGroupName, accountName, shareName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, shareName, options }, deleteOperationSpec$2);
    }
    /**
     * Restore a file share within a valid retention days if share soft delete is enabled
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param shareName The name of the file share within the specified storage account. File share names
     *                  must be between 3 and 63 characters in length and use numbers, lower-case letters and dash (-) only.
     *                  Every dash (-) character must be immediately preceded and followed by a letter or number.
     * @param deletedShare The deleted share to be restored.
     * @param options The options parameters.
     */
    restore(resourceGroupName, accountName, shareName, deletedShare, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, shareName, deletedShare, options }, restoreOperationSpec);
    }
    /**
     * The Lease Share operation establishes and manages a lock on a share for delete operations. The lock
     * duration can be 15 to 60 seconds, or can be infinite.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param shareName The name of the file share within the specified storage account. File share names
     *                  must be between 3 and 63 characters in length and use numbers, lower-case letters and dash (-) only.
     *                  Every dash (-) character must be immediately preceded and followed by a letter or number.
     * @param options The options parameters.
     */
    lease(resourceGroupName, accountName, shareName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, shareName, options }, leaseOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, accountName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, nextLink, options }, listNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/fileServices/default/shares",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FileShareItems
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        filter,
        maxpagesize1,
        expand2
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const createOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/fileServices/default/shares/{shareName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: FileShare
        },
        201: {
            bodyMapper: FileShare
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: fileShare,
    queryParameters: [apiVersion, expand2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        shareName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$4
};
const updateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/fileServices/default/shares/{shareName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: FileShare
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: fileShare,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        shareName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$4
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/fileServices/default/shares/{shareName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FileShare
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        shareName
    ],
    headerParameters: [accept, xMsSnapshot],
    serializer: serializer$4
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/fileServices/default/shares/{shareName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, include2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        shareName
    ],
    headerParameters: [accept, xMsSnapshot],
    serializer: serializer$4
};
const restoreOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/fileServices/default/shares/{shareName}/restore",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: deletedShare,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        shareName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$4
};
const leaseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/fileServices/default/shares/{shareName}/lease",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: LeaseShareResponse,
            headersMapper: FileSharesLeaseHeaders
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters10,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        shareName
    ],
    headerParameters: [
        accept,
        contentType,
        xMsSnapshot
    ],
    mediaType: "json",
    serializer: serializer$4
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FileShareItems
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing QueueServices operations. */
class QueueServicesImpl {
    /**
     * Initialize a new instance of the class QueueServices class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all queue services for the storage account
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    list(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listOperationSpec$3);
    }
    /**
     * Sets the properties of a storage account’s Queue service, including properties for Storage Analytics
     * and CORS (Cross-Origin Resource Sharing) rules.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param parameters The properties of a storage account’s Queue service, only properties for Storage
     *                   Analytics and CORS (Cross-Origin Resource Sharing) rules can be specified.
     * @param options The options parameters.
     */
    setServiceProperties(resourceGroupName, accountName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, parameters, options }, setServicePropertiesOperationSpec$1);
    }
    /**
     * Gets the properties of a storage account’s Queue service, including properties for Storage Analytics
     * and CORS (Cross-Origin Resource Sharing) rules.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    getServiceProperties(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, getServicePropertiesOperationSpec$1);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/queueServices",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListQueueServices
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const setServicePropertiesOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/queueServices/{queueServiceName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: QueueServiceProperties
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters11,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        queueServiceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const getServicePropertiesOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/queueServices/{queueServiceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: QueueServiceProperties
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        queueServiceName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Queue operations. */
class QueueImpl {
    /**
     * Initialize a new instance of the class Queue class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of all the queues under the specified storage account
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    list(resourceGroupName, accountName, options) {
        const iter = this.listPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, accountName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, accountName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, accountName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, accountName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Creates a new queue with the specified queue name, under the specified account.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param queueName A queue name must be unique within a storage account and must be between 3 and 63
     *                  characters.The name must comprise of lowercase alphanumeric and dash(-) characters only, it should
     *                  begin and end with an alphanumeric character and it cannot have two consecutive dash(-) characters.
     * @param queue Queue properties and metadata to be created with
     * @param options The options parameters.
     */
    create(resourceGroupName, accountName, queueName, queue, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, queueName, queue, options }, createOperationSpec$1);
    }
    /**
     * Creates a new queue with the specified queue name, under the specified account.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param queueName A queue name must be unique within a storage account and must be between 3 and 63
     *                  characters.The name must comprise of lowercase alphanumeric and dash(-) characters only, it should
     *                  begin and end with an alphanumeric character and it cannot have two consecutive dash(-) characters.
     * @param queue Queue properties and metadata to be created with
     * @param options The options parameters.
     */
    update(resourceGroupName, accountName, queueName, queue, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, queueName, queue, options }, updateOperationSpec$1);
    }
    /**
     * Gets the queue with the specified queue name, under the specified account if it exists.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param queueName A queue name must be unique within a storage account and must be between 3 and 63
     *                  characters.The name must comprise of lowercase alphanumeric and dash(-) characters only, it should
     *                  begin and end with an alphanumeric character and it cannot have two consecutive dash(-) characters.
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, queueName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, queueName, options }, getOperationSpec$1);
    }
    /**
     * Deletes the queue with the specified queue name, under the specified account if it exists.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param queueName A queue name must be unique within a storage account and must be between 3 and 63
     *                  characters.The name must comprise of lowercase alphanumeric and dash(-) characters only, it should
     *                  begin and end with an alphanumeric character and it cannot have two consecutive dash(-) characters.
     * @param options The options parameters.
     */
    delete(resourceGroupName, accountName, queueName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, queueName, options }, deleteOperationSpec$1);
    }
    /**
     * Gets a list of all the queues under the specified storage account
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    _list(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listOperationSpec$2);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, accountName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/queueServices/default/queues/{queueName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StorageQueue
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: queue,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        queueName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const updateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/queueServices/default/queues/{queueName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: StorageQueue
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: queue,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        queueName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/queueServices/default/queues/{queueName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StorageQueue
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        queueName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/queueServices/default/queues/{queueName}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        queueName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/queueServices/default/queues",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListQueueResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        filter,
        maxpagesize1
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListQueueResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing TableServices operations. */
class TableServicesImpl {
    /**
     * Initialize a new instance of the class TableServices class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all table services for the storage account.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    list(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listOperationSpec$1);
    }
    /**
     * Sets the properties of a storage account’s Table service, including properties for Storage Analytics
     * and CORS (Cross-Origin Resource Sharing) rules.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param parameters The properties of a storage account’s Table service, only properties for Storage
     *                   Analytics and CORS (Cross-Origin Resource Sharing) rules can be specified.
     * @param options The options parameters.
     */
    setServiceProperties(resourceGroupName, accountName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, parameters, options }, setServicePropertiesOperationSpec);
    }
    /**
     * Gets the properties of a storage account’s Table service, including properties for Storage Analytics
     * and CORS (Cross-Origin Resource Sharing) rules.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    getServiceProperties(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, getServicePropertiesOperationSpec);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/tableServices",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListTableServices
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const setServicePropertiesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/tableServices/{tableServiceName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: TableServiceProperties
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters12,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        tableServiceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};
const getServicePropertiesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/tableServices/{tableServiceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TableServiceProperties
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        tableServiceName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing TableOperations operations. */
class TableOperationsImpl {
    /**
     * Initialize a new instance of the class TableOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of all the tables under the specified storage account
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    list(resourceGroupName, accountName, options) {
        const iter = this.listPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, accountName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, accountName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, accountName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, accountName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Creates a new table with the specified table name, under the specified account.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param tableName A table name must be unique within a storage account and must be between 3 and 63
     *                  characters.The name must comprise of only alphanumeric characters and it cannot begin with a numeric
     *                  character.
     * @param options The options parameters.
     */
    create(resourceGroupName, accountName, tableName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, tableName, options }, createOperationSpec);
    }
    /**
     * Creates a new table with the specified table name, under the specified account.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param tableName A table name must be unique within a storage account and must be between 3 and 63
     *                  characters.The name must comprise of only alphanumeric characters and it cannot begin with a numeric
     *                  character.
     * @param options The options parameters.
     */
    update(resourceGroupName, accountName, tableName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, tableName, options }, updateOperationSpec);
    }
    /**
     * Gets the table with the specified table name, under the specified account if it exists.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param tableName A table name must be unique within a storage account and must be between 3 and 63
     *                  characters.The name must comprise of only alphanumeric characters and it cannot begin with a numeric
     *                  character.
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, tableName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, tableName, options }, getOperationSpec);
    }
    /**
     * Deletes the table with the specified table name, under the specified account if it exists.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param tableName A table name must be unique within a storage account and must be between 3 and 63
     *                  characters.The name must comprise of only alphanumeric characters and it cannot begin with a numeric
     *                  character.
     * @param options The options parameters.
     */
    delete(resourceGroupName, accountName, tableName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, tableName, options }, deleteOperationSpec);
    }
    /**
     * Gets a list of all the tables under the specified storage account
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param options The options parameters.
     */
    _list(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param accountName The name of the storage account within the specified resource group. Storage
     *                    account names must be between 3 and 24 characters in length and use numbers and lower-case letters
     *                    only.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, accountName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/tableServices/default/tables/{tableName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Table
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters13,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        tableName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/tableServices/default/tables/{tableName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Table
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters13,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        tableName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/tableServices/default/tables/{tableName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Table
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        tableName
    ],
    headerParameters: [accept],
    serializer
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/tableServices/default/tables/{tableName}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        tableName
    ],
    headerParameters: [accept],
    serializer
};
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/tableServices/default/tables",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListTableResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1
    ],
    headerParameters: [accept],
    serializer
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListTableResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName1,
        nextLink
    ],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class StorageManagementClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the StorageManagementClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId The ID of the target subscription.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-storage/18.2.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
            });
            this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                }
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2023-01-01";
        this.operations = new OperationsImpl(this);
        this.skus = new SkusImpl(this);
        this.storageAccounts = new StorageAccountsImpl(this);
        this.deletedAccounts = new DeletedAccountsImpl(this);
        this.usages = new UsagesImpl(this);
        this.managementPolicies = new ManagementPoliciesImpl(this);
        this.blobInventoryPolicies = new BlobInventoryPoliciesImpl(this);
        this.privateEndpointConnections = new PrivateEndpointConnectionsImpl(this);
        this.privateLinkResources = new PrivateLinkResourcesImpl(this);
        this.objectReplicationPoliciesOperations = new ObjectReplicationPoliciesOperationsImpl(this);
        this.localUsersOperations = new LocalUsersOperationsImpl(this);
        this.encryptionScopes = new EncryptionScopesImpl(this);
        this.blobServices = new BlobServicesImpl(this);
        this.blobContainers = new BlobContainersImpl(this);
        this.fileServices = new FileServicesImpl(this);
        this.fileShares = new FileSharesImpl(this);
        this.queueServices = new QueueServicesImpl(this);
        this.queue = new QueueImpl(this);
        this.tableServices = new TableServicesImpl(this);
        this.tableOperations = new TableOperationsImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            sendRequest(request, next) {
                return tslib.__awaiter(this, void 0, void 0, function* () {
                    const param = request.url.split("?");
                    if (param.length > 1) {
                        const newParams = param[1].split("&").map((item) => {
                            if (item.indexOf("api-version") > -1) {
                                return "api-version=" + apiVersion;
                            }
                            else {
                                return item;
                            }
                        });
                        request.url = param[0] + "?" + newParams.join("&");
                    }
                    return next(request);
                });
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
}

exports.StorageManagementClient = StorageManagementClient;
exports.getContinuationToken = getContinuationToken;
//# sourceMappingURL=index.js.map
