/// <reference types="node" />
import events = require('events');
import stream = require('stream');
export declare function cp(source: string, dest: string, options?: string, continueOnError?: boolean): void;
export declare function _checkShell(cmd: string, continueOnError?: boolean): void;
export declare function mkdirP(p: string): void;
export declare function find(findPath: string): string[];
interface MatchOptions {
    debug?: boolean;
    nobrace?: boolean;
    noglobstar?: boolean;
    dot?: boolean;
    noext?: boolean;
    nocase?: boolean;
    nonull?: boolean;
    matchBase?: boolean;
    nocomment?: boolean;
    nonegate?: boolean;
    flipNegate?: boolean;
}
export declare function match(list: string[], patterns: string[] | string, patternRoot?: string, options?: MatchOptions): string[];
/**
 * Exec a tool synchronously.  Convenience wrapper over ToolRunner to execSync with args in one call.
 * Output will be *not* be streamed to the live console.  It will be returned after execution is complete.
 * Appropriate for short running tools
 * Returns IExecResult with output and return code
 *
 * @param     tool     path to tool to exec
 * @param     args     an arg string or array of args
 * @param     options  optional exec options.  See IExecSyncOptions
 * @returns   IExecSyncResult
 */
export declare function execSync(tool: string, args: string | string[], options?: IExecSyncOptions): IExecSyncResult;
/**
 * Convenience factory to create a ToolRunner.
 *
 * @param     tool     path to tool to exec
 * @returns   ToolRunner
 */
export declare function tool(tool: string): ToolRunner;
/**
 * Interface for execSync options
 */
export interface IExecSyncOptions {
    /** optional working directory.  defaults to current */
    cwd?: string;
    /** optional envvar dictionary.  defaults to current process's env */
    env?: {
        [key: string]: string;
    };
    /** optional.  defaults to false */
    silent?: boolean;
    outStream: stream.Writable;
    errStream: stream.Writable;
    /** optional.  foo.whether to skip quoting/escaping arguments if needed.  defaults to false. */
    windowsVerbatimArguments?: boolean;
}
/**
 * Interface for exec results returned from synchronous exec functions
 */
export interface IExecSyncResult {
    /** standard output */
    stdout: string;
    /** error output */
    stderr: string;
    /** return code */
    code: number;
    /** Error on failure */
    error: Error;
}
declare class ToolRunner extends events.EventEmitter {
    constructor(toolPath: string);
    private toolPath;
    private args;
    private pipeOutputToTool;
    private _argStringToArray;
    private _getCommandString;
    private _getSpawnFileName;
    private _getSpawnArgs;
    private _isCmdFile;
    private _windowsQuoteCmdArg;
    private _uv_quote_cmd_arg;
    private _cloneExecOptions;
    private _getSpawnSyncOptions;
    /**
     * Add argument
     * Append an argument or an array of arguments
     * returns ToolRunner for chaining
     *
     * @param     val        string cmdline or array of strings
     * @returns   ToolRunner
     */
    arg(val: string | string[]): ToolRunner;
    /**
     * Parses an argument line into one or more arguments
     * e.g. .line('"arg one" two -z') is equivalent to .arg(['arg one', 'two', '-z'])
     * returns ToolRunner for chaining
     *
     * @param     val        string argument line
     * @returns   ToolRunner
     */
    line(val: string): ToolRunner;
    /**
     * Exec a tool synchronously.
     * Output will be *not* be streamed to the live console.  It will be returned after execution is complete.
     * Appropriate for short running tools
     * Returns IExecSyncResult with output and return code
     *
     * @param     tool     path to tool to exec
     * @param     options  optional exec options.  See IExecSyncOptions
     * @returns   IExecSyncResult
     */
    execSync(options?: IExecSyncOptions): IExecSyncResult;
}
export {};
